-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Diagrams based plotting library.
--   
--   Diagrams based plotting library.
@package plots
@version 0.1.0.0


-- | This module defines a class for coordinates that are (loosely)
--   isomorphic to the standard spaces (<a>V2</a> and <a>V3</a>). This
--   allows plots to accept more data types for plot data.
module Diagrams.Coordinates.Isomorphic
type HasIndexedBasis v = (HasBasis v, TraversableWithIndex (E v) v)

-- | Umbrella class giving everything needed for working in the space. This
--   is basically <a>V2</a> or <a>V3</a> from "linear".
type Euclidean v = (HasLinearMap v, HasIndexedBasis v, Metric v)

-- | Provides an <a>Iso'</a> between <tt>a</tt> and <tt>v n</tt>. This is
--   normally used to convert between the data type you're already using,
--   <tt>a</tt>, and diagram's native form, <tt>v n</tt>.
class (Euclidean v, Typeable v) => VectorLike v n a | a -> v n where unvectorLike = from vectorLike

-- | Isomorphism from <tt>Point v n</tt> to something <a>PointLike</a>
--   <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; V2 3 5 ^. vectorLike :: (Int, Int)
--   (3,5)
--   </pre>
vectorLike :: VectorLike v n a => Iso' (v n) a

-- | Isomorphism from something <a>PointLike</a> <tt>a</tt> to <tt>Point v
--   n</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; ((3, 5) :: (Int, Int)) ^. unvectorLike
--   V2 3 5
--   </pre>
unvectorLike :: VectorLike v n a => Iso' a (v n)
type V2Like = VectorLike V2
type V3Like = VectorLike V3

-- | Provides an <a>Iso'</a> between <tt>a</tt> and <tt><a>Point</a> v
--   n</tt>. This is normally used to convert between the data type you're
--   already using, <tt>a</tt>, and diagram's native form, <tt><a>Point</a>
--   v n</tt>.
class (Euclidean v, Typeable v) => PointLike v n a | a -> v n where unpointLike = from pointLike

-- | Isomorphism from <tt><a>Point</a> v n</tt> to something
--   <a>PointLike</a> <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; mkP2 3 5 ^. pointLike :: (Int, Int)
--   (3,5)
--   </pre>
pointLike :: PointLike v n a => Iso' (Point v n) a

-- | Isomorphism from something <a>PointLike</a> <tt>a</tt> to <tt>Point v
--   n</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; ((3, 5) :: (Int, Int)) ^. unpointLike
--   P (V2 3 5)
--   </pre>
unpointLike :: PointLike v n a => Iso' a (Point v n)

-- | Things that are isomorphic to points in R2.
type P2Like = PointLike V2
type P3Like = PointLike V3
instance Diagrams.Coordinates.Isomorphic.VectorLike Linear.V2.V2 n (Linear.V2.V2 n)
instance (n ~ m) => Diagrams.Coordinates.Isomorphic.VectorLike Linear.V2.V2 n (n, m)
instance Diagrams.Coordinates.Isomorphic.VectorLike Linear.V2.V2 n (Data.Complex.Complex n)
instance Diagrams.Coordinates.Isomorphic.VectorLike Linear.V3.V3 n (Linear.V3.V3 n)
instance (n ~ m, m ~ o) => Diagrams.Coordinates.Isomorphic.VectorLike Linear.V3.V3 n (n, m, o)
instance (Diagrams.Coordinates.Isomorphic.Euclidean v, Data.Typeable.Internal.Typeable v) => Diagrams.Coordinates.Isomorphic.PointLike v n (Linear.Affine.Point v n)
instance Diagrams.Coordinates.Isomorphic.PointLike Linear.V2.V2 n (Linear.V2.V2 n)
instance (n ~ m) => Diagrams.Coordinates.Isomorphic.PointLike Linear.V2.V2 n (n, m)
instance Diagrams.Coordinates.Isomorphic.PointLike Linear.V2.V2 n (Data.Complex.Complex n)
instance (n ~ m, m ~ o) => Diagrams.Coordinates.Isomorphic.PointLike Linear.V3.V3 n (n, m, o)

module Plots.Name
data PlotName n
PlotName :: String -> SizeSpec V2 n -> T2 n -> PlotName n
[_plotName] :: PlotName n -> String
[_namedSize2D] :: PlotName n -> SizeSpec V2 n
[_namedT2] :: PlotName n -> T2 n
plotName :: Lens' (PlotName n_ahEd) String
namedT2 :: Lens' (PlotName n_ahEd) (T2 n_ahEd)
namedSize2D :: Lens' (PlotName n_ahEd) (SizeSpec V2 n_ahEd)
instance GHC.Show.Show (Plots.Name.PlotName n)
instance GHC.Classes.Eq (Plots.Name.PlotName n)
instance GHC.Classes.Ord (Plots.Name.PlotName n)
instance Data.Typeable.Internal.Typeable n => Diagrams.Core.Names.IsName (Plots.Name.PlotName n)


-- | This module defines a polar coordinate data type. This type can be
--   used as an axis space for polar plots.
module Diagrams.Coordinates.Polar
newtype Polar a
Polar :: (V2 a) -> Polar a

-- | Construct a <a>Polar</a> from a magnitude and an <a>Angle</a>.
mkPolar :: n -> Angle n -> Polar n

-- | Construct a <a>Polar</a> from a magnitude and <a>Angle</a> tuple.
polar :: (n, Angle n) -> Polar n

-- | Turn a <a>Polar</a> back into a magnitude and <a>Angle</a> tuple.
unpolar :: Polar n -> (n, Angle n)

-- | <a>Iso'</a> between <a>Polar</a> and its tuple form.
polarIso :: Iso' (Polar n) (n, Angle n)

-- | Numerical <a>Iso'</a> between <a>Polar</a> and <a>R2</a>.
polarV2 :: RealFloat n => Iso' (Polar n) (V2 n)

-- | Polar interpolation between two polar coordinates.
interpPolar :: Num n => n -> Polar n -> Polar n -> Polar n

-- | Space which has a radial length basis. For Polar and Cylindrical this
--   is the radius of the circle in the xy-plane. For Spherical this is the
--   distance from the origin.
class Radial t
_radial :: Radial t => Lens' (t a) a

-- | Space which has a radial and angular basis.
class Radial t => Circle t
_azimuth :: Circle t => Lens' (t a) (Angle a)
_polar :: Circle t => Lens' (t a) (Polar a)

-- | Coordinate with at least one dimension where the x coordinate can be
--   retreived numerically. Note this differs slightly from <a>R1</a> which
--   requires a lens for all values. This allows instances for different
--   coordinates such as <a>Polar</a>, where the x coordinate can only be
--   retreived numerically.
class HasX t
x_ :: (HasX t, RealFloat n) => Lens' (t n) n

-- | Coordinate with at least two dimensions where the x and y coordinates
--   can be retreived numerically.
class HasX t => HasY t where y_ = xy_ . _y
y_ :: (HasY t, RealFloat n) => Lens' (t n) n
xy_ :: (HasY t, RealFloat n) => Lens' (t n) (V2 n)

-- | A space which has magnitude <a>_r</a> that can be calculated
--   numerically.
class HasR (t :: * -> *)
_r :: (HasR t, RealFloat n) => Lens' (t n) n
er :: Circle v => E v
eÎ¸ :: Circle v => E v
etheta :: Circle v => E v
instance (Diagrams.Coordinates.Polar.Polar a1 ~ t0) => Control.Lens.Wrapped.Rewrapped (Diagrams.Coordinates.Polar.Polar a0) t0
instance Control.Lens.Wrapped.Wrapped (Diagrams.Coordinates.Polar.Polar a0)
instance Data.Distributive.Distributive Diagrams.Coordinates.Polar.Polar
instance Data.Functor.Rep.Representable Diagrams.Coordinates.Polar.Polar
instance Diagrams.Coordinates.Polar.Circle Diagrams.Coordinates.Polar.Polar
instance Diagrams.Coordinates.Polar.Radial Diagrams.Coordinates.Polar.Polar
instance Diagrams.Coordinates.Polar.HasX v => Diagrams.Coordinates.Polar.HasX (Linear.Affine.Point v)
instance Diagrams.Coordinates.Polar.HasX Linear.V2.V2
instance Diagrams.Coordinates.Polar.HasX Linear.V3.V3
instance Diagrams.Coordinates.Polar.HasX Diagrams.Coordinates.Polar.Polar
instance Diagrams.Coordinates.Polar.HasY v => Diagrams.Coordinates.Polar.HasY (Linear.Affine.Point v)
instance Diagrams.Coordinates.Polar.HasY Linear.V2.V2
instance Diagrams.Coordinates.Polar.HasY Linear.V3.V3
instance Diagrams.Coordinates.Polar.HasY Diagrams.Coordinates.Polar.Polar
instance GHC.Float.RealFloat n => Diagrams.Coordinates.Isomorphic.PointLike Linear.V2.V2 n (Diagrams.Coordinates.Polar.Polar n)
instance GHC.Generics.Constructor Diagrams.Coordinates.Polar.C1_0Polar
instance GHC.Generics.Datatype Diagrams.Coordinates.Polar.D1Polar
instance Data.Foldable.Foldable Diagrams.Coordinates.Polar.Polar
instance Control.Monad.Zip.MonadZip Diagrams.Coordinates.Polar.Polar
instance GHC.Generics.Generic1 Diagrams.Coordinates.Polar.Polar
instance Data.Traversable.Traversable Diagrams.Coordinates.Polar.Polar
instance GHC.Base.Applicative Diagrams.Coordinates.Polar.Polar
instance Control.Monad.Fix.MonadFix Diagrams.Coordinates.Polar.Polar
instance GHC.Base.Functor Diagrams.Coordinates.Polar.Polar
instance GHC.Base.Monad Diagrams.Coordinates.Polar.Polar

module Plots.Utils

-- | Apply a function over two recommends or two commits. If only one of
--   the values is a commit, the commit is used without applying the
--   function.
liftRecommend :: (a -> a -> a) -> Recommend a -> Recommend a -> Recommend a

-- | Extract a commit value, defaulting to the provided value when it is a
--   recommend.
fromCommit :: a -> Recommend a -> a

-- | Type specialised version of <a>fromVertices</a>.
pathFromVertices :: (Metric v, OrderedField n) => [Point v n] -> Path v n

-- | Minmax of a getter in the form <tt>V2 min max</tt>. Returns <tt>(V2
--   (-Infinity) Infinity)</tt> for empty folds.
minMaxOf :: (Fractional a, Ord a) => Getting (Endo (Endo (V2 a))) s a -> s -> (a, a)

-- | <tt>enumFromToN a b n</tt> calculates a list from <tt>a</tt> to
--   <tt>b</tt> in <tt>n</tt> steps.
enumFromToN :: Fractional n => n -> n -> Int -> [n]

-- | Similar to '(%=)' but takes a state modification instead of a
--   function.
(&=) :: MonadState s m => ASetter' s b -> State b a -> m ()

-- | Similar to '(&amp;~)' but works with <a>StateT</a> and returns it in
--   <tt>m</tt>.
(&~~) :: Monad m => s -> StateT s m a -> m s


-- | Ticks for being placed on an axis or a <tt>ColourBar</tt>.
module Plots.Axis.Ticks

-- | The big ticks on the axis line.
data MajorTicks v n

-- | Class of things that have a single <a>MajorTicks</a>.
class HasMajorTicks f a where majorTickFunction = majorTicks . lens matFunction (\ mat a -> mat {matFunction = a}) majorTickAlign = majorTicks . lens matAlign (\ mat a -> mat {matAlign = a}) majorTickLength = majorTicks . lens matLength (\ mat a -> mat {matLength = a}) majorTickStyle = majorTicks . lens matStyle (\ mat sty -> mat {matStyle = sty}) majorTickVisible = majorTicks . lens matVisible (\ mat b -> mat {matVisible = b})

-- | Lens onto the <a>MajorTicks</a> of something.
majorTicks :: HasMajorTicks f a => LensLike' f a (MajorTicks (V a) (N a))

-- | The function used to place ticks for this axis, given the bounds of
--   the axis. The result of these major ticks are also used as guides for
--   <a>MinorTicks</a>, <tt>MajorGridLines</tt> and
--   <tt>MinorGridLines</tt>.
--   
--   Default is <tt><a>linearMinorTicks</a> 5</tt>.
majorTickFunction :: (HasMajorTicks f a, Functor f) => LensLike' f a ((N a, N a) -> [N a])

-- | Alignment of the major ticks. Choose between <a>autoTicks</a>
--   (default), <a>centreTicks</a>, <a>insideTicks</a> or
--   <a>outsideTicks</a>.
majorTickAlign :: (HasMajorTicks f a, Functor f) => LensLike' f a TickAlign

-- | The total length the major ticks.
--   
--   Default is <tt>7</tt>.
majorTickLength :: (HasMajorTicks f a, Functor f) => LensLike' f a (N a)

-- | The style used to render the major ticks.
--   
--   Default is <tt><a>lwO</a> 0.6 <a>mempty</a></tt> (subject to change).
majorTickStyle :: (HasMajorTicks f a, Functor f) => LensLike' f a (Style (V a) (N a))

-- | Whether the major ticks should be <tt>visible</tt>.
--   
--   Default is <a>True</a>.
majorTickVisible :: (HasMajorTicks f a, Functor f) => LensLike' f a Bool

-- | Choose ticks whose step size is a multiple of 10 of the allowed
--   numbers and tries to match the number of desired ticks.
majorTicksHelper :: (Enum n, RealFrac n, Floating n) => [n] -> n -> (n, n) -> [n]

-- | Place n ticks at powers of 10 on the axis.
logMajorTicks :: (Enum n, RealFrac n, Floating n) => n -> (n, n) -> [n]

-- | The small ticks on the axis line.
data MinorTicks v n

-- | Class of things that have a single <a>MinorTicks</a>.
class HasMinorTicks f a where minorTickFunction = minorTicks . lens mitFunction (\ mit a -> mit {mitFunction = a}) minorTickAlign = minorTicks . lens mitAlign (\ mit a -> mit {mitAlign = a}) minorTickLength = minorTicks . lens mitLength (\ mit a -> mit {mitLength = a}) minorTickStyle = minorTicks . lens mitStyle (\ mit sty -> mit {mitStyle = sty}) minorTickVisible = minorTicks . lens mitVisible (\ mit sty -> mit {mitVisible = sty})

-- | Lens onto the <a>MinorTicks</a> of something.
minorTicks :: HasMinorTicks f a => LensLike' f a (MinorTicks (V a) (N a))

-- | The function used to place ticks for this axis, given the result of
--   <tt>majorTicksFunction</tt> and the bounds of the axis.
--   
--   Default is <tt><a>linearMinorTicks</a> 3</tt>.
minorTickFunction :: (HasMinorTicks f a, Functor f) => LensLike' f a ([N a] -> (N a, N a) -> [N a])

-- | Alignment of the minor ticks. Choose between <a>autoTicks</a>
--   (default), <a>centreTicks</a>, <a>insideTicks</a> or
--   <a>outsideTicks</a>.
minorTickAlign :: (HasMinorTicks f a, Functor f) => LensLike' f a TickAlign

-- | The total length the minor ticks.
--   
--   Default is <tt>3</tt>.
minorTickLength :: (HasMinorTicks f a, Functor f) => LensLike' f a (N a)

-- | The style used to render the minor ticks.
--   
--   Default is <tt><a>lwO</a> 0.4 <a>mempty</a></tt> (subject to change).
minorTickStyle :: (HasMinorTicks f a, Functor f) => LensLike' f a (Style (V a) (N a))

-- | The style used to render the minor ticks.
--   
--   Default is <a>True</a>.
minorTickVisible :: (HasMinorTicks f a, Functor f) => LensLike' f a Bool

-- | Place n linear spaced ticks between each major tick.
minorTicksHelper :: Fractional n => Int -> [n] -> (n, n) -> [n]

-- | Both <a>MajorTicks</a> and <a>MinorTicks</a> together.
data Ticks v n

-- | Class of things with both <a>MajorTicks</a> and <a>MinorTicks</a>.
class (HasMinorTicks f a, HasMajorTicks f a) => HasTicks f a
bothTicks :: HasTicks f a => LensLike' f a (Ticks (V a) (N a))

-- | Traversal over both major and minor tick alignment.
ticksAlign :: (HasTicks f a, Applicative f) => LensLike' f a TickAlign

-- | Traversal over both major and minor tick styles.
ticksStyle :: (HasTicks f a, Applicative f) => LensLike' f a (Style (V a) (N a))

-- | Traversal over the visibility of both major and minor ticks.
ticksVisible :: (HasTicks f a, Applicative f) => LensLike' f a Bool

-- | Set the portion of the tick above and below the axis.
data TickAlign
TickSpec :: !Rational -> !Rational -> TickAlign
AutoTick :: TickAlign

-- | Set the tick type depending on the axis line position.
--   <tt>centreTick</tt> for <tt>middleAxis</tt>, <tt>insideTick</tt> for
--   everything else.
autoTicks :: TickAlign

-- | Set the tick to be in the centre of the axis with total length of the
--   corresponding tick length.
centreTicks :: TickAlign

-- | Synonym for <a>centreTicks</a>.
centerTicks :: TickAlign

-- | Align the ticks to be inside a box axis.
insideTicks :: TickAlign

-- | Align the ticks to be outside a box axis.
outsideTicks :: TickAlign

-- | Hides the <tt>Major</tt> ticks when trying to render something. This
--   can be used on multiple types:
--   
--   <pre>
--   <a>hideMajorTicks</a> :: <tt>Axis</tt> b c n       -&gt; <tt>Axis</tt> b c n
--   <a>hideMajorTicks</a> :: <tt>SingleAxis</tt> b v n -&gt; <tt>SingleAxis</tt> b v n
--   <a>hideMajorTicks</a> :: <a>Ticks</a> v n        -&gt; <a>Ticks</a> v n
--   <a>hideMajorTicks</a> :: <a>MajorTicks</a> v n   -&gt; <a>MajorTicks</a> v n
--   <a>hideMajorTicks</a> :: <tt>ColourBar</tt> b n    -&gt; <tt>ColourBar</tt> b n
--   </pre>
hideMajorTicks :: HasMajorTicks Identity a => a -> a

-- | Hides the <tt>Minor</tt> ticks when trying to render something. This
--   can be used on multiple types:
--   
--   <pre>
--   <a>hideMinorTicks</a> :: <tt>Axis</tt> b c n       -&gt; <tt>Axis</tt> b c n
--   <a>hideMinorTicks</a> :: <tt>SingleAxis</tt> b v n -&gt; <tt>SingleAxis</tt> b v n
--   <a>hideMinorTicks</a> :: <a>Ticks</a> v n        -&gt; <a>Ticks</a> v n
--   <a>hideMinorTicks</a> :: <a>MinorTicks</a> v n   -&gt; <a>MinorTicks</a> v n
--   </pre>
hideMinorTicks :: HasMinorTicks Identity a => a -> a

-- | Hides the <tt>Minor</tt> ticks when trying to render something. This
--   can be used on multiple types:
--   
--   <pre>
--   <a>hideTicks</a> :: <tt>Axis</tt> b c n       -&gt; <tt>Axis</tt> b c n
--   <a>hideTicks</a> :: <tt>SingleAxis</tt> b v n -&gt; <tt>SingleAxis</tt> b v n
--   <a>hideTicks</a> :: <a>Ticks</a> v n        -&gt; <a>Ticks</a> v n
--   <a>hideTicks</a> :: <a>MinorTicks</a> v n   -&gt; <a>MinorTicks</a> v n
--   </pre>
hideTicks :: HasTicks Identity a => a -> a

-- | Setter over the final positions the major ticks. This is not as
--   general as <tt>majorTicksFunction</tt> because you don't have access
--   to the bounds but it can be useful when you know exactly what ticks
--   you want to add or modify existing tick positions.
majorTickPositions :: (HasMajorTicks f a, Settable f) => LensLike' f a [N a]

-- | Setter over the final positions the major ticks. This is not as
--   general as <tt>minorTicksFunction</tt> because you don't have access
--   to the bounds but it can be useful when you know exactly what ticks
--   you want to add or modify existing tick positions.
minorTickPositions :: (HasMinorTicks f a, Settable f) => LensLike' f a [N a]
instance GHC.Classes.Eq Plots.Axis.Ticks.TickAlign
instance GHC.Show.Show Plots.Axis.Ticks.TickAlign
instance (GHC.Enum.Enum n, Diagrams.Core.Types.TypeableFloat n) => Data.Default.Class.Default (Plots.Axis.Ticks.MajorTicks v n)
instance Plots.Axis.Ticks.HasMajorTicks f (Plots.Axis.Ticks.MajorTicks v n)
instance (GHC.Enum.Enum n, Diagrams.Core.Types.TypeableFloat n) => Data.Default.Class.Default (Plots.Axis.Ticks.MinorTicks v n)
instance Plots.Axis.Ticks.HasMinorTicks f (Plots.Axis.Ticks.MinorTicks v n)
instance GHC.Base.Functor f => Plots.Axis.Ticks.HasTicks f (Plots.Axis.Ticks.Ticks v n)
instance GHC.Base.Functor f => Plots.Axis.Ticks.HasMajorTicks f (Plots.Axis.Ticks.Ticks v n)
instance GHC.Base.Functor f => Plots.Axis.Ticks.HasMinorTicks f (Plots.Axis.Ticks.Ticks v n)
instance (Diagrams.Core.Types.TypeableFloat n, GHC.Enum.Enum n) => Data.Default.Class.Default (Plots.Axis.Ticks.Ticks v n)
instance Data.Typeable.Internal.Typeable n => Diagrams.Core.Style.HasStyle (Plots.Axis.Ticks.Ticks v n)


-- | Determine how to scale an axis.
module Plots.Axis.Scale

-- | Data type used that concerns everything to do with the size or scale
--   of the axis.
data AxisScaling n

-- | How the axis should be scaled when not all dimensions are set.
data ScaleMode
AutoScale :: ScaleMode
NoScale :: ScaleMode
Stretch :: ScaleMode
UniformScale :: UniformScaleStrategy -> ScaleMode

-- | ?
data UniformScaleStrategy
AutoUniformScale :: UniformScaleStrategy
UnitOnly :: UniformScaleStrategy
ChangeVerticalLimits :: UniformScaleStrategy
ChangeHorizontalLimits :: UniformScaleStrategy

-- | How much to extend the bounds beyond any inferred bounds.
data Extending n
AbsoluteExtend :: n -> Extending n
RelativeExtend :: n -> Extending n

-- | Class of things that have an <a>AxisScaling</a>.
class HasAxisScaling f a where scaleAspectRatio = axisScaling . lens asRatio (\ as r -> as {asRatio = r}) scalePostScale = axisScaling . lens asPostScale (\ as r -> as {asPostScale = r}) scaleRatio = axisScaling . lens asRatio (\ as r -> as {asRatio = r}) scaleMode = axisScaling . lens asMode (\ as r -> as {asMode = r}) logScale = axisScaling . lens asLogScale (\ as r -> as {asLogScale = r}) axisExtend = axisScaling . lens asEnlarge (\ as r -> as {asEnlarge = r}) boundMax = axisScaling . lens asBoundMax (\ as b -> as {asBoundMax = b}) boundMin = axisScaling . lens asBoundMin (\ as b -> as {asBoundMin = b}) renderSize = axisScaling . lens asSize (\ as s -> as {asSize = s})

-- | The way to scale in one direction.
axisScaling :: HasAxisScaling f a => LensLike' f a (AxisScaling (N a))

-- | The ratio between this axis and other axes.
scaleAspectRatio :: (HasAxisScaling f a, Functor f) => LensLike' f a (Maybe (N a))

-- | How much to extend the bounds beyond any inferred bounds.
scalePostScale :: (HasAxisScaling f a, Functor f) => LensLike' f a (Maybe (N a))

-- | The ratio relative to other axis. If no ratios are set, the ratio is
--   not enforced. If at least one is set, <a>Nothing</a> ratios are
--   <tt>1</tt>.
scaleRatio :: (HasAxisScaling f a, Functor f) => LensLike' f a (Maybe (N a))

-- | The mode to determine how to scale the bounds in a direction. Choose
--   between <a>AutoScale</a>, <a>NoScale</a>, <a>Stretch</a> or
--   <a>UniformScale</a>.
--   
--   <a>Default</a> is <a>AutoScale</a>.
scaleMode :: (HasAxisScaling f a, Functor f) => LensLike' f a ScaleMode

-- | Whether the axis uses <a>LogAxis</a> or <a>LinearAxis</a>.
--   
--   <a>Default</a> is <a>LinearAxis</a>.
logScale :: (HasAxisScaling f a, Functor f) => LensLike' f a LogScale

-- | How much to extend the bounds over infered bounds. This is ignored if
--   a <a>boundMax</a> or <a>boundMin</a> is set.
axisExtend :: (HasAxisScaling f a, Functor f) => LensLike' f a (Extending (N a))

-- | The maximum bound the axis.
boundMax :: (HasAxisScaling f a, Functor f) => LensLike' f a (Maybe (N a))

-- | The minimum bound the axis.
boundMin :: (HasAxisScaling f a, Functor f) => LensLike' f a (Maybe (N a))

-- | The size of the rendered axis. Default is 500.
renderSize :: (HasAxisScaling f a, Functor f) => LensLike' f a (Maybe (N a))

-- | Should the axis be on a logarithmic scale. The <a>Default</a> is
--   <a>LinearAxis</a>.
data LogScale
LinearAxis :: LogScale
LogAxis :: LogScale

-- | Log the number for <a>LogAxis</a>, do nothing for <a>LinearAxis</a>.
logNumber :: Floating a => LogScale -> a -> a

-- | Transform a point according to the axis scale. Does nothing for linear
--   scales.
logPoint :: (Additive v, Floating n) => v LogScale -> Point v n -> Point v n

-- | Deform an object according to the axis scale. Does nothing for linear
--   scales.
logDeform :: (InSpace v n a, Additive v, Foldable v, Floating n, Deformable a a) => v LogScale -> a -> a

-- | Calculating the bounds for an axis.
calculateBounds :: Num n => AxisScaling n -> Maybe (n, n) -> (n, n)

-- | Calculate the scaling for the axis.
--   
--   The result returns:
--   
--   <ul>
--   <li>The final bounds for the axis</li>
--   <li>scale to match desired <a>scaleAspectRatio</a></li>
--   <li>scale to match desired <a>asSizeSpec</a></li>
--   </ul>
calculateScaling :: (HasLinearMap v, Distributive v, OrderedField n, Applicative v, Metric v) => v (AxisScaling n) -> BoundingBox v n -> (v (n, n), Transformation v n, Transformation v n)
instance GHC.Classes.Eq Plots.Axis.Scale.LogScale
instance GHC.Show.Show Plots.Axis.Scale.LogScale
instance GHC.Base.Functor Plots.Axis.Scale.Extending
instance GHC.Classes.Eq n => GHC.Classes.Eq (Plots.Axis.Scale.Extending n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Plots.Axis.Scale.Extending n)
instance GHC.Show.Show n => GHC.Show.Show (Plots.Axis.Scale.Extending n)
instance GHC.Read.Read Plots.Axis.Scale.ScaleMode
instance GHC.Show.Show Plots.Axis.Scale.ScaleMode
instance GHC.Read.Read Plots.Axis.Scale.UniformScaleStrategy
instance GHC.Show.Show Plots.Axis.Scale.UniformScaleStrategy
instance GHC.Real.Fractional n => Data.Default.Class.Default (Plots.Axis.Scale.AxisScaling n)
instance Plots.Axis.Scale.HasAxisScaling f (Plots.Axis.Scale.AxisScaling n)
instance Data.Default.Class.Default Plots.Axis.Scale.LogScale


-- | Lines that go along the axis. Supports major and minor gird lines
--   separately for each axis.
module Plots.Axis.Grid
data GridLines v n
class HasGridLines f a where majorGridLineFunction = gridLines . lens magFun (\ gl maf -> gl {magFun = maf}) minorGridLineFunction = gridLines . lens migFun (\ gl mif -> gl {migFun = mif}) majorGridLineStyle = gridLines . lens magStyle (\ gl sty -> gl {magStyle = sty}) minorGridLineStyle = gridLines . lens migStyle (\ gl sty -> gl {migStyle = sty}) majorGridLineVisible = gridLines . lens magVisible (\ gl b -> gl {magVisible = b}) minorGridLineVisible = gridLines . lens migVisible (\ gl b -> gl {migVisible = b})

-- | The options for how to draw the grid lines. This can be used on
--   various levels of the axis:
--   
--   <pre>
--   <a>gridLines</a> :: <a>Traversal'</a> (<tt>Axis</tt> b c n)       (<a>GridLines</a> (<tt>BaseSpace</tt> c) n)
--   <a>gridLines</a> :: <a>Lens'</a>      (<tt>SingleAxis</tt> b v n) (<a>GridLines</a> v n)
--   <a>gridLines</a> :: <a>Lens'</a>      (<a>GridLines</a> v n)    (<a>GridLines</a> v n)
--   </pre>
gridLines :: HasGridLines f a => LensLike' f a (GridLines (V a) (N a))

-- | The function to calculate location of the major grid lines given
--   location of the major ticks and bounds.
majorGridLineFunction :: (HasGridLines f a, Functor f) => LensLike' f a (GridLineFunction (N a))

-- | The function to calculate location of the minor grid lines given
--   location of the minor ticks and bounds.
minorGridLineFunction :: (HasGridLines f a, Functor f) => LensLike' f a (GridLineFunction (N a))

-- | The style applied to the major grid lines.
majorGridLineStyle :: (HasGridLines f a, Functor f) => LensLike' f a (Style (V a) (N a))

-- | The style applied to the minor grid lines.
minorGridLineStyle :: (HasGridLines f a, Functor f) => LensLike' f a (Style (V a) (N a))

-- | Whether the major grid lines should be visible.
--   
--   Default is <a>True</a>.
majorGridLineVisible :: (HasGridLines f a, Functor f) => LensLike' f a Bool

-- | Whether the minor grid lines should be visible.
--   
--   Default is <a>False</a>.
minorGridLineVisible :: (HasGridLines f a, Functor f) => LensLike' f a Bool

-- | Traversal over both the major and minor grid styles. This can be used
--   at seversal levels in the Axis:
gridLineStyle :: (HasGridLines f a, Applicative f) => LensLike' f a (Style (V a) (N a))

-- | Traversal over both the major and minor grid styles.
--   
--   <pre>
--   <tt>gridLinesVisible</tt> :: <a>Traversal'</a> (<tt>Axis</tt> b c n) <a>Bool</a>
--   <tt>gridLinesVisible</tt> :: <a>Traversal'</a> (<tt>SingleAxis</tt> b v n) <a>Bool</a>
--   <tt>gridLinesVisible</tt> :: <a>Traversal'</a> (<a>GridLines</a> v n) <a>Bool</a>
--   </pre>
gridLineVisible :: (HasGridLines f a, Applicative f) => LensLike' f a Bool

-- | Hide both major and minor grid lines.
--   
--   <pre>
--   <a>hideGridLines</a> :: <tt>Axis</tt> b c n       -&gt; <tt>Axis</tt> b c n
--   <a>hideGridLines</a> :: <tt>SingleAxis</tt> b c n -&gt; <tt>SingleAxis</tt> b c n
--   <a>hideGridLines</a> :: <a>GridLines</a> b c n  -&gt; <tt>GirdLines</tt> b c n
--   </pre>
--   
--   See <a>HasGridLines</a> for more advanced visibility options.
hideGridLines :: (HasGridLines Identity a, MonadState a m) => m ()

-- | Show both major and minor grid lines.
--   
--   <pre>
--   <a>showGridLines</a> :: <tt>Axis</tt> b c n       -&gt; <tt>Axis</tt> b c n
--   <a>showGridLines</a> :: <tt>SingleAxis</tt> b c n -&gt; <tt>SingleAxis</tt> b c n
--   <a>showGridLines</a> :: <a>GridLines</a> b c n  -&gt; <tt>GirdLines</tt> b c n
--   </pre>
--   
--   See <a>HasGridLines</a> for more advanced visibility options.
showGridLines :: (HasGridLines Identity a, MonadState a m) => m ()

-- | A grid line function takes the positions of the respective ticks
--   (minor ticks for minor grid lines, major ticks for major grid lines)
--   and the bounds of the axis and returns the positions of the grid
--   lines.
--   
--   These functions are used in conjuction with
--   <a>majorGridLineFunction</a> and <a>minorGridLineFunction</a> to
--   control how the lines are drawn.
type GridLineFunction n = [n] -> (n, n) -> [n]

-- | Place grid lines at the same position as the respective ticks. This is
--   the <a>Default</a>.
onTicksGridLineFunction :: GridLineFunction n

-- | The <a>GridLineFunction</a> such that no grid lines appear.
--   
--   See <a>hideGridLines</a>, <a>majorGridLineVisible</a> or
--   <a>minorGridLineVisible</a> if you just want to hide the grid lines.
emptyGridLineFunction :: GridLineFunction n
instance Plots.Axis.Grid.HasGridLines f (Plots.Axis.Grid.GridLines v n)
instance (Data.Typeable.Internal.Typeable n, GHC.Float.Floating n) => Data.Default.Class.Default (Plots.Axis.Grid.GridLines v n)
instance Data.Typeable.Internal.Typeable n => Diagrams.Core.Style.HasStyle (Plots.Axis.Grid.GridLines v n)


-- | This module defines the <a>AxisStyle</a> type along with different
--   colour schemes. <a>AxisStyle</a>s are used to provide default colours
--   and shapes for the plots of an axis.
module Plots.Style

-- | The <a>AxisStyle</a> determines the <a>Style</a>s of the plots in an
--   axis. There are various predifined styles to change the look of the
--   plot.
data AxisStyle b v n

-- | Class of things that have an <a>AxisStyle</a>.
class HasAxisStyle a b | a -> b where axisColourMap = axisStyle . cm where cm f (AxisStyle c ss) = f c <&> \ c' -> AxisStyle c' ss axisStyles = axisStyle . stys . traversed where stys f (AxisStyle c ss) = f ss <&> \ ss' -> AxisStyle c ss'

-- | Lens onto the <a>AxisStyle</a>.
axisStyle :: HasAxisStyle a b => Lens' a (AxisStyle b (V a) (N a))

-- | The <a>ColourMap</a> is used to draw the <a>ColourBar</a> and render
--   plots like <a>HeatMap</a>.
axisColourMap :: HasAxisStyle a b => Lens' a ColourMap

-- | Traversal over the <a>PlotStyle</a>s in an <a>AxisStyle</a>. There are
--   always an infinite number of <a>PlotStyle</a>s in an <a>AxisStyle</a>.
axisStyles :: HasAxisStyle a b => IndexedTraversal' Int a (PlotStyle b (V a) (N a))

-- | Theme using <tt>funColours</tt> with faded fills and thick lines.
--   
fadedColours :: (TypeableFloat n, Renderable (Path V2 n) b) => AxisStyle b V2 n

-- | Theme using <tt>funColours</tt> with no lines on 'areaStyle.
--   
vividColours :: (TypeableFloat n, Renderable (Path V2 n) b) => AxisStyle b V2 n

-- | Theme without any colours, useful for black and white documents.
--   
blackAndWhite :: (TypeableFloat n, Renderable (Path V2 n) b) => AxisStyle b V2 n

-- | A plot style is made up of separate styles (<a>lineStyle</a>,
--   <a>markerStyle</a>, <a>areaStyle</a> and <a>textStyle</a>) a
--   <a>plotColour</a> and a <a>plotMarker</a>. When rendering a plot, the
--   <a>PlotStyle</a>s in an <a>AxisStyle</a> are used to style each plot.
--   The lenses can be used to customise each style when adding the plot.
data PlotStyle b v n

-- | Class for objects that contain a <a>PlotStyle</a>.
class HasPlotStyle f a b | a -> b where plotColour = plotStyle . lens _plotColor (\ p f -> p {_plotColor = f}) plotColor = plotStyle . lens _plotColor (\ p f -> p {_plotColor = f}) lineStyle = lineStyleFunction . mapped lineStyleFunction = plotStyle . lens _lineStyle (\ p f -> p {_lineStyle = f}) markerStyle = markerStyleFunction . mapped markerStyleFunction = plotStyle . lens _markerStyle (\ p f -> p {_markerStyle = f}) areaStyle = areaStyleFunction . mapped areaStyleFunction = plotStyle . lens _areaStyle (\ p f -> p {_areaStyle = f}) textStyle = textStyleFunction . mapped textStyleFunction = plotStyle . lens _textStyle (\ p f -> p {_textStyle = f}) plotMarker = plotStyle . lens _plotMarker (\ p f -> p {_plotMarker = f}) plotStyles = plotStyleFunctions . mapped plotStyleFunctions = plotStyle . t where t f (PlotStyle {..}) = PlotStyle <$> pure _plotColor <*> f _lineStyle <*> f _markerStyle <*> f _areaStyle <*> f _textStyle <*> pure _plotMarker

-- | Lens onto the <a>PlotStyle</a>.
plotStyle :: HasPlotStyle f a b => LensLike' f a (PlotStyle b (V a) (N a))

-- | The <a>plotColor</a> is the overall colour of the plot. This is passed
--   to the other styles (<a>lineStyle</a>, <a>markerStyle</a> etc.) to
--   give an overall colour for the plot.
plotColour :: (HasPlotStyle f a b, Functor f) => LensLike' f a (Colour Double)

-- | Alias for <a>plotColour</a>.
plotColor :: (HasPlotStyle f a b, Functor f) => LensLike' f a (Colour Double)

-- | This style is applied to any plots made up of lines only (like
--   <a>Path</a> plots). This is a less general version of
--   <a>lineStyleFunction</a>.
lineStyle :: (HasPlotStyle f a b, Settable f) => LensLike' f a (Style (V a) (N a))

-- | A version <a>lineStyle</a> with access to the current
--   <a>plotColour</a> when <a>applyLineStyle</a> is used.
lineStyleFunction :: (HasPlotStyle f a b, Functor f) => LensLike' f a (Colour Double -> Style (V a) (N a))

-- | This style is applied to any markers in the plot (usually the
--   <a>plotMarker</a>). This is a less general version of
--   <a>markerStyleFunction</a>.
markerStyle :: (HasPlotStyle f a b, Settable f) => LensLike' f a (Style (V a) (N a))

-- | A version <a>lineStyle</a> with access to the current
--   <a>plotColour</a> when <a>applyMarkerStyle</a> is used.
markerStyleFunction :: (HasPlotStyle f a b, Functor f) => LensLike' f a (Colour Double -> Style (V a) (N a))

-- | This style is applied to any filled areas in a plot (like <a>Bar</a>
--   or <a>Ribbon</a>). This is a less general version of
--   <a>areaStyleFunction</a>.
areaStyle :: (HasPlotStyle f a b, Settable f) => LensLike' f a (Style (V a) (N a))

-- | A version <a>areaStyle</a> with access to the current
--   <a>plotColour</a> when <a>applyAreaStyle</a> is used.
areaStyleFunction :: (HasPlotStyle f a b, Functor f) => LensLike' f a (Colour Double -> Style (V a) (N a))

-- | This style is applied to text plots. This is a less general version of
--   <a>textStyleFunction</a>.
textStyle :: (HasPlotStyle f a b, Settable f) => LensLike' f a (Style (V a) (N a))

-- | A version <a>textStyle</a> with access to the current
--   <a>plotColour</a> when <a>applyAreaStyle</a> is used.
textStyleFunction :: (HasPlotStyle f a b, Functor f) => LensLike' f a (Colour Double -> Style (V a) (N a))

-- | This diagram is used as any markers in a plot (like <a>Scatter</a>).
--   The <a>markerStyle</a> will be applied to this marker when the plot
--   gets rendered.
plotMarker :: (HasPlotStyle f a b, Functor f) => LensLike' f a (QDiagram b (V a) (N a) Any)

-- | A traversal over all the styles (<a>lineStyle</a>, <a>markerStyle</a>,
--   <a>areaStyle</a> and <a>textStyle</a>) of a <a>PlotStyle</a>. This is
--   a less general version of <a>plotStyleFunctions</a>.
plotStyles :: (HasPlotStyle f a b, Settable f) => LensLike' f a (Style (V a) (N a))

-- | A version of <a>plotStyles</a> with access to the <a>plotColour</a>.
plotStyleFunctions :: (HasPlotStyle f a b, Applicative f) => LensLike' f a (Colour Double -> Style (V a) (N a))

-- | Apply the <a>lineStyle</a> from a <a>PlotStyle</a>.
applyLineStyle :: (SameSpace a t, HasPlotStyle (Const (PlotStyle b (V a) (N a))) a b, HasStyle t) => a -> t -> t

-- | Apply the <a>markerStyle</a> from a <a>PlotStyle</a>.
applyMarkerStyle :: (SameSpace a t, HasPlotStyle (Const (PlotStyle b (V a) (N a))) a b, HasStyle t) => a -> t -> t

-- | Apply the 'areaStyle from a <a>PlotStyle</a>.
applyAreaStyle :: (SameSpace a t, HasPlotStyle (Const (PlotStyle b (V a) (N a))) a b, HasStyle t) => a -> t -> t

-- | Apply the <a>textStyle</a> from a <a>PlotStyle</a>.
applyTextStyle :: (SameSpace a t, HasPlotStyle (Const (PlotStyle b (V a) (N a))) a b, HasStyle t) => a -> t -> t

-- | A colourful colour set used for <a>fadedColours</a>.
colours1 :: OrderedField n => [Colour n]

-- | Another colour set, used for <a>vividColours</a>.
colours2 :: OrderedField n => [Colour n]

-- | Make an asterisk with <tt>n</tt> spokes, each of length <tt>l</tt>.
asterisk :: OrderedField n => Int -> n -> Path V2 n

-- | A rotated <a>square</a>.
diamond :: (InSpace V2 n t, TrailLike t) => n -> t

-- | A rotated <a>plus</a>.
crossShape :: (InSpace V2 n t, TrailLike t) => n -> t

-- | A filled in five sided start of size x.
star' :: (InSpace V2 n t, TrailLike t) => n -> t

-- | Filled in <tt>+</tt> symbol.
plus :: (InSpace V2 n t, TrailLike t) => n -> t

-- | <a>asterisk</a> markers with varying numbers of prongs.
lineMarkers :: OrderedField n => [Path V2 n]

-- | A map from a number (usually between 0 and 1) to a colour. Colour maps
--   are part of the <a>AxisStyle</a>, which is used for plots like
--   <a>HeatMap</a>.
data ColourMap
ixColour :: Rational -> Lens' ColourMap (AlphaColour Double)

-- | Indexed traversal over the colours indexed and ordered by their
--   position in the map.
cmTraverse :: IndexedTraversal' Rational ColourMap (AlphaColour Double)
colourMap :: [(Rational, Colour Double)] -> ColourMap
alphaColourMap :: [(Rational, AlphaColour Double)] -> ColourMap

-- | Return the list of colours in the [0,1] range in order. This always
--   includes colours 0 and 1.
colourList :: ColourMap -> [(Rational, AlphaColour Double)]
toStops :: Fractional n => ColourMap -> [GradientStop n]
hot :: ColourMap
instance GHC.Show.Show Plots.Style.ColourMap
instance Plots.Style.HasPlotStyle f (Plots.Style.PlotStyle b v n) b
instance (Linear.Metric.Metric v, Data.Traversable.Traversable v, Diagrams.Core.Envelope.OrderedField n) => Diagrams.Core.Transform.Transformable (Plots.Style.PlotStyle b v n)
instance Plots.Style.HasAxisStyle (Plots.Style.AxisStyle b v n) b
instance Control.Lens.Wrapped.Rewrapped Plots.Style.ColourMap Plots.Style.ColourMap
instance Control.Lens.Wrapped.Wrapped Plots.Style.ColourMap
instance Diagrams.Core.Transform.Transformable Plots.Style.ColourMap
instance Control.Lens.Empty.AsEmpty Plots.Style.ColourMap
instance Control.Lens.Each.Each Plots.Style.ColourMap Plots.Style.ColourMap (Data.Colour.Internal.AlphaColour GHC.Types.Double) (Data.Colour.Internal.AlphaColour GHC.Types.Double)
instance Control.Lens.At.Ixed Plots.Style.ColourMap
instance Control.Lens.At.At Plots.Style.ColourMap


-- | This module defines the various types for holding plots:
--   
--   <ul>
--   <li><i><tt><a>PlotOptions</a> b v n</tt></i> Generic options all plots
--   have.</li>
--   <li><i><tt><a>PlotMods</a> b v n</tt></i> Includes <a>PlotOptions</a>
--   along with modifications to the <a>PlotStyle</a>.</li>
--   <li><i><tt><a>Plot</a> p b</tt></i> A <a>rawPlot</a> <tt>p</tt>
--   grouped with a <a>PlotMods</a>.</li>
--   <li><i><tt><a>DynamicPlot</a> b v n</tt></i> A wrapped up <a>Plot</a>
--   so it can be stored in an <tt>Axis</tt>.</li>
--   <li><i><tt><a>StyledPlot</a> b v n</tt></i> A <a>DynamicPlot</a> with
--   a concrete <a>PlotStyle</a>, ready to be rendered.</li>
--   </ul>
--   
--   As well as other things like the <a>Plotable</a> class,
--   <tt>LegendEntries</tt>, <a>HasOrientation</a> and
--   <a>HasVisibility</a>.
module Plots.Types

-- | Data type for holding information all plots must contain.
data PlotOptions b v n

-- | Class of things that have <a>PlotOptions</a>.
class HasPlotOptions f a b | a -> b where plotName = plotOptions . lens poName (\ g a -> g {poName = a}) clipPlot = plotOptions . lens poClipPlot (\ g a -> g {poClipPlot = a}) legendEntries = plotOptions . lens poLegend (\ g a -> g {poLegend = a}) plotTransform = plotOptions . lens poTransform (\ g a -> g {poTransform = a}) plotVisible = plotOptions . lens poVisible (\ po b -> po {poVisible = b})

-- | Lens onto the <a>PlotOptions</a>.
plotOptions :: HasPlotOptions f a b => LensLike' f a (PlotOptions b (V a) (N a))

-- | The <a>Name</a> applied to the plot. This gives a way to reference a
--   specific plot in a rendered axis.
--   
--   <a>Default</a> is <a>mempty</a>.
plotName :: (HasPlotOptions f a b, Functor f) => LensLike' f a Name

-- | Whether the plot should be clipped to the bounds of the axes.
--   
--   <a>Default</a> is <a>True</a>.
clipPlot :: (HasPlotOptions f a b, Functor f) => LensLike' f a Bool

-- | The legend entries to be used for the current plot.
--   
--   <a>Default</a> is <a>mempty</a>.
legendEntries :: (HasPlotOptions f a b, Functor f) => LensLike' f a [LegendEntry b (V a) (N a)]

-- | The transform applied to the plot once it's in the axis coordinates.
--   
--   <a>Default</a> is <a>mempty</a>.
plotTransform :: (HasPlotOptions f a b, Functor f) => LensLike' f a (Transformation (V a) (N a))

-- | Whether or not the plot should be shown. The <a>BoundingBox</a> of the
--   plot will still affect the inferred axis bounds.
--   
--   <a>Default</a> is <a>True</a>.
plotVisible :: (HasPlotOptions f a b, Functor f) => LensLike' f a Bool

-- | Add a <a>LegendEntry</a> to something with <a>PlotOptions</a> using
--   the <a>String</a> as the <a>legendText</a> and a
--   <a>DefaultLegendPic</a>. Here are some typical examples:
--   
--   <pre>
--   <a>key</a> :: <a>String</a> -&gt; <a>State</a> (<a>Plot</a> (<tt>ScatterPlot</tt> v n) b) ()
--   <a>key</a> :: <a>String</a> -&gt; <a>State</a> (<a>DynamicPlot</a> b v n) ()
--   <a>key</a> :: <a>String</a> -&gt; <a>State</a> (<a>PlotMods</a> b v n) ()
--   </pre>
--   
--   If you only care about the name of the legend, use <a>key</a>.
key :: (HasPlotOptions Identity a b, MonadState a m, Num (N a)) => String -> m ()

-- | Add a <a>LegendEntry</a> to something with <a>PlotOptions</a>. Here
--   are some typical examples:
--   
--   <pre>
--   <a>addLegendEntry</a> :: <a>LegendEntry</a> b v n -&gt; <a>State</a> (<a>Plot</a> (<tt>ScatterPlot</tt> v n) b) ()
--   <a>addLegendEntry</a> :: <a>LegendEntry</a> b v n -&gt; <a>State</a> (<a>DynamicPlot</a> b v n) ()
--   </pre>
--   
--   If you only care about the name of the legend, use <a>key</a>.
addLegendEntry :: (HasPlotOptions Identity a b, MonadState a m, Num (N a)) => LegendEntry b (V a) (N a) -> m ()

-- | A <a>PlotOptions</a> with modifications to a <a>PlotStyle</a>.
data PlotMods b v n

-- | The modifications to the <a>PlotOptions</a> and <a>PlotStyle</a> in a
--   <a>Plot</a>.
plotMods :: Lens' (Plot p b) (PlotMods b (V p) (N p))

-- | Class defining how plots should be rendered.
class (Typeable p, Enveloped p) => Plotable p b where defLegendPic = mempty

-- | Render a plot according to the <a>AxisSpec</a>, using the
--   <a>PlotStyle</a>.
renderPlotable :: (Plotable p b, InSpace v n p) => AxisSpec v n -> PlotStyle b v n -> p -> QDiagram b v n Any

-- | The default legend picture when the <a>LegendPic</a> is
--   <a>DefaultLegendPic</a>.
defLegendPic :: (Plotable p b, InSpace v n p, OrderedField n) => PlotStyle b v n -> p -> QDiagram b v n Any

-- | A parameterised plot, together with a <a>PlotMods</a>. This type has
--   an instance of many classes for modifying specific plots.
data Plot p b

-- | Make a <a>Plot</a> with <a>Default</a> <a>PlotOptions</a>.
mkPlot :: (Additive (V p), Num (N p)) => p -> Plot p b

-- | Lens onto the raw <a>Plotable</a> inside a <a>Plot</a>.
rawPlot :: SameSpace p p' => Lens (Plot p b) (Plot p' b) p p'

-- | A wrapped up <a>Plot</a>, used to store plots in an <tt>Axis</tt>.
data DynamicPlot b v n
DynamicPlot :: Plot p b -> DynamicPlot b v n

-- | Prism for a <a>DynamicPlot</a>.
_DynamicPlot :: (Plotable p b, Typeable b) => Prism' (DynamicPlot b (V p) (N p)) (Plot p b)

-- | The modifications to the <a>PlotOptions</a> and <a>PlotStyle</a> in a
--   <a>DynamicPlot</a>.
dynamicPlotMods :: Lens' (DynamicPlot b v n) (PlotMods b v n)

-- | A <a>DynamicPlot</a> with a concrete style. This is suitable for being
--   rendered with <tt>styledPlotRender</tt> and get extract the legend
--   entries with 'styledPlotLegend.
--   
--   You can make a <a>StyledPlot</a> with <a>styleDynamic</a>
data StyledPlot b v n

-- | Give a <a>DynamicPlot</a> a concrete <a>PlotStyle</a>.
styleDynamic :: PlotStyle b v n -> DynamicPlot b v n -> StyledPlot b v n

-- | Render a <a>StyledPlot</a> given an and <a>AxisSpec</a>.
renderStyledPlot :: AxisSpec v n -> StyledPlot b v n -> QDiagram b v n Any

-- | Get the legend rendered entries from a single styled plot. The
--   resulting entries are in no particular order. See also
--   <a>styledPlotLegends</a>.
singleStyledPlotLegend :: StyledPlot b v n -> [(n, QDiagram b v n Any, String)]

-- | Render a list of legend entries, in order.
styledPlotLegends :: Ord n => [StyledPlot b v n] -> [(QDiagram b v n Any, String)]

-- | Class of objects that can be hidden.
class HasVisibility a where hidden = visible . involuted not

-- | Lens onto whether an object should be visible when rendered.
visible :: HasVisibility a => Lens' a Bool

-- | The opposite of <a>visible</a>.
hidden :: HasVisibility a => Lens' a Bool
data Orientation
Horizontal :: Orientation
Vertical :: Orientation

-- | Class of things that have an orientation.
class HasOrientation a

-- | Lens onto the orientation of an object.
orientation :: HasOrientation a => Lens' a Orientation

-- | Pick the first <tt>a</tt> if the object has <a>Horizontal</a>
--   orientation and the second <tt>a</tt> if the object has a
--   <a>Vertical</a> orientation.
orient :: HasOrientation o => o -> a -> a -> a

-- | Lens onto whether an object's orientation is horizontal.
horizontal :: HasOrientation a => Lens' a Bool

-- | Lens onto whether an object's orientation is vertical.
vertical :: HasOrientation a => Lens' a Bool

-- | Data type for holding a legend entry.
data LegendEntry b v n

-- | Type allowing use of the default legend picture (depending on the
--   plot) or a custom legend picture with access to the <a>PlotStyle</a>.
data LegendPic b v n
DefaultLegendPic :: LegendPic b v n
CustomLegendPic :: (PlotStyle b v n -> QDiagram b v n Any) -> LegendPic b v n

-- | Make a legend entry with a default <a>legendPicture</a> and
--   <a>legendPrecedence</a> 0 using the string as the <a>legendText</a>.
mkLegendEntry :: Num n => String -> LegendEntry b v n

-- | The picture used in the legend entry.
legendPicture :: Lens' (LegendEntry b v n) (LegendPic b v n)

-- | The text used in the legend entry.
legendText :: Lens' (LegendEntry b v n) String

-- | The order in which the legend entries are rendered. If precedence are
--   equal, they entries are put in the order they are added to the axis.
--   
--   Default is <tt>0</tt>.
legendPrecedence :: Lens' (LegendEntry b v n) n

-- | Information from the <a>Axis</a> necessary to render a
--   <a>Plotable</a>.
data AxisSpec v n
AxisSpec :: v (n, n) -> Transformation v n -> v LogScale -> ColourMap -> AxisSpec v n
[_specBounds] :: AxisSpec v n -> v (n, n)
[_specTrans] :: AxisSpec v n -> Transformation v n
[_specScale] :: AxisSpec v n -> v LogScale
[_specColourMap] :: AxisSpec v n -> ColourMap
specTrans :: Lens' (AxisSpec v_a1ewu n_a1ewv) (Transformation v_a1ewu n_a1ewv)
specBounds :: Lens' (AxisSpec v_a1ewu n_a1ewv) (v_a1ewu (n_a1ewv, n_a1ewv))
specScale :: Lens' (AxisSpec v_a1ewu n_a1ewv) (v_a1ewu LogScale)

-- | Scale a number by log10-ing it and linearly scaling it so it's within
--   the same range.
scaleNum :: Floating n => (n, n) -> LogScale -> n -> n

-- | Apply log scaling and the transform to a point.
specPoint :: (Applicative v, Additive v, Floating n) => AxisSpec v n -> Point v n -> Point v n
specColourMap :: Lens' (AxisSpec v_a1ewu n_a1ewv) ColourMap
instance (Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable v, Linear.Metric.Metric v, Data.Typeable.Internal.Typeable n, Diagrams.Core.Envelope.OrderedField n) => Plots.Types.Plotable (Diagrams.Core.Types.QDiagram b v n Data.Monoid.Any) b
instance GHC.Base.Functor f => Plots.Types.HasPlotOptions f (Plots.Types.PlotMods b v n) b
instance Control.Lens.Internal.Setter.Settable f => Plots.Style.HasPlotStyle f (Plots.Types.PlotMods b v n) b
instance (Linear.Vector.Additive v, GHC.Num.Num n) => Data.Default.Class.Default (Plots.Types.PlotMods b v n)
instance GHC.Base.Functor f => Plots.Types.HasPlotOptions f (Plots.Types.Plot p b) b
instance Control.Lens.Internal.Setter.Settable f => Plots.Style.HasPlotStyle f (Plots.Types.Plot p b) b
instance Plots.Types.HasOrientation p => Plots.Types.HasOrientation (Plots.Types.Plot p b)
instance GHC.Base.Functor f => Plots.Types.HasPlotOptions f (Plots.Types.DynamicPlot b v n) b
instance Control.Lens.Internal.Setter.Settable f => Plots.Style.HasPlotStyle f (Plots.Types.DynamicPlot b v n) b
instance GHC.Base.Functor f => Plots.Types.HasPlotOptions f (Plots.Types.StyledPlot b v n) b
instance (Linear.Metric.Metric v, Diagrams.Core.Envelope.OrderedField n) => Diagrams.Core.Envelope.Enveloped (Plots.Types.StyledPlot b v n)
instance GHC.Base.Functor f => Plots.Style.HasPlotStyle f (Plots.Types.StyledPlot b v n) b
instance GHC.Classes.Ord Plots.Types.Orientation
instance GHC.Classes.Eq Plots.Types.Orientation
instance GHC.Show.Show Plots.Types.Orientation
instance Plots.Types.HasOrientation Plots.Types.Orientation
instance Data.Default.Class.Default (Plots.Types.LegendPic b v n)
instance (Linear.Vector.Additive v, GHC.Num.Num n) => Data.Default.Class.Default (Plots.Types.PlotOptions b v n)
instance Plots.Types.HasPlotOptions f (Plots.Types.PlotOptions b v n) b
instance (Diagrams.Core.Transform.HasLinearMap v, GHC.Num.Num n) => Diagrams.Core.Transform.Transformable (Plots.Types.PlotOptions b v n)
instance (Linear.Vector.Additive v, GHC.Num.Num n) => Diagrams.Core.HasOrigin.HasOrigin (Plots.Types.PlotOptions b v n)
instance Diagrams.Core.Names.Qualifiable (Plots.Types.PlotOptions b v n)


-- | Low level module defining types for axis labels and tick labels.
module Plots.Axis.Labels
class HasAxisLabel f a b | a -> b where axisLabelText = axisLabel . lens alText (\ al txt -> al {alText = txt}) axisLabelTextFunction = axisLabel . lens alFun (\ al f -> al {alFun = f}) axisLabelGap = axisLabel . lens alGap (\ al sty -> al {alGap = sty}) axisLabelStyle = axisLabel . lens alStyle (\ al sty -> al {alStyle = sty}) axisLabelPosition = axisLabel . lens alPos (\ al sty -> al {alPos = sty}) axisLabelPlacement = axisLabel . lens alPos (\ al sty -> al {alPos = sty}) axisLabelVisible = axisLabel . lens alVisible (\ al b -> al {alVisible = b})

-- | The options for the label of the axis. This can be used on various
--   levels of the axis:
--   
--   <pre>
--   <a>axisLabel</a> :: <a>Traversal'</a> (<tt>Axis</tt> b c n)       (<a>AxisLabel</a> (<tt>BaseSpace</tt> c) n)
--   <a>axisLabel</a> :: <a>Lens'</a>      (<tt>SingleAxis</tt> b v n) (<a>AxisLabel</a> v n)
--   <a>axisLabel</a> :: <a>Lens'</a>      (<a>AxisLabel</a> v n)    (<a>AxisLabel</a> v n)
--   </pre>
axisLabel :: HasAxisLabel f a b => LensLike' f a (AxisLabel b (V a) (N a))

-- | The text to use when labeling the axis.
axisLabelText :: (HasAxisLabel f a b, Functor f) => LensLike' f a String

-- | The <a>TextFunction</a> to render the text of the axis label.
axisLabelTextFunction :: (HasAxisLabel f a b, Functor f) => LensLike' f a (TextFunction b (V a) (N a))

-- | The gap between the axis and the labels, in the direction
--   corresponding to the <a>axisLabelPosition</a>.
axisLabelGap :: (HasAxisLabel f a b, Functor f) => LensLike' f a (N a)

-- | The <a>Style</a> to use on the rendered text.
axisLabelStyle :: (HasAxisLabel f a b, Functor f) => LensLike' f a (Style (V a) (N a))

-- | The position the label will be placed parallel the axis.
axisLabelPosition :: (HasAxisLabel f a b, Functor f) => LensLike' f a AxisLabelPosition

-- | Whether the axis label should be placed inside or outside the axis.
axisLabelPlacement :: (HasAxisLabel f a b, Functor f) => LensLike' f a AxisLabelPosition

-- | Whether the axis label should be visible.
axisLabelVisible :: (HasAxisLabel f a b, Functor f) => LensLike' f a Bool
data AxisLabel b v n

-- | The position of the <a>AxisLabel</a> along the axis.
data AxisLabelPosition
MiddleAxisLabel :: AxisLabelPosition
LowerAxisLabel :: AxisLabelPosition
UpperAxisLabel :: AxisLabelPosition

-- | Whether the <a>AxisLabel</a> should be inside or ouside the axis.
data AxisLabelPlacement
InsideAxisLabel :: AxisLabelPlacement
OutsideAxisLabel :: AxisLabelPlacement
data TickLabels b v n
class HasTickLabels f a b | a -> b where tickLabelTextFunction = tickLabel . lens tlTextFun (\ tl f -> tl {tlTextFun = f}) tickLabelFunction = tickLabel . lens tlFun (\ tl f -> tl {tlFun = f}) tickLabelStyle = tickLabel . lens tlStyle (\ tl sty -> tl {tlStyle = sty}) tickLabelGap = tickLabel . lens tlGap (\ tl n -> tl {tlGap = n}) tickLabelVisible = tickLabel . lens tlVisible (\ tl b -> tl {tlVisible = b})

-- | The options for the label of ticks. This can be used on various levels
--   of the axis:
--   
--   <pre>
--   <a>tickLabel</a> :: <a>Traversal'</a> (<tt>Tick</tt> b c n)       (<tt>TickLabel</tt> (<tt>BaseSpace</tt> c) n)
--   <a>tickLabel</a> :: <a>Lens'</a>      (<tt>SingleAxis</tt> b v n) (<tt>TickLabel</tt> v n)
--   <a>tickLabel</a> :: <a>Lens'</a>      (<tt>TickLabel</tt> v n)    (<tt>TickLabel</tt> v n)
--   </pre>
tickLabel :: HasTickLabels f a b => LensLike' f a (TickLabels b (V a) (N a))

-- | The <a>TextFunction</a> to render the text.
--   
--   <a>Default</a> is <tt><a>atMajorTicks</a> <a>floatShow</a></tt>
tickLabelTextFunction :: (HasTickLabels f a b, Functor f) => LensLike' f a (TextFunction b (V a) (N a))

-- | The <a>TextFunction</a> to render the text.
--   
--   <a>Default</a> is <a>mkText</a>.
tickLabelFunction :: (HasTickLabels f a b, Functor f) => LensLike' f a (TickLabelFunction (N a))

-- | The <a>Style</a> to use on the rendered text.
--   
--   <a>Default</a> is <tt><a>fontSize</a> (<a>output</a> 11)</tt>.
tickLabelStyle :: (HasTickLabels f a b, Functor f) => LensLike' f a (Style (V a) (N a))

-- | The gap between the axis and the tick labels.
--   
--   <a>Default</a> is <tt>12</tt>.
tickLabelGap :: (HasTickLabels f a b, Functor f) => LensLike' f a (N a)

-- | Whether the axis label should be visible.
--   
--   <a>Default</a> is <a>True</a>.
tickLabelVisible :: (HasTickLabels f a b, Functor f) => LensLike' f a Bool

-- | Setter over the final positions the major ticks. This is not as
--   general as <tt>minorTicksFunction</tt> because you don't have access
--   to the bounds but it can be useful when you know exactly what ticks
--   you want to add or modify existing tick positions.
tickLabelPositions :: (HasTickLabels f a b, Settable f) => LensLike' f a [(N a, String)]

-- | Make a <a>TickLabelFunction</a> by specifying how to draw a single
--   label from a position on the axis.
atMajorTicks :: (n -> String) -> TickLabelFunction n
instance Plots.Axis.Labels.HasAxisLabel f (Plots.Axis.Labels.AxisLabel b v n) b
instance Data.Typeable.Internal.Typeable n => Diagrams.Core.Style.HasStyle (Plots.Axis.Labels.AxisLabel b v n)
instance Plots.Types.HasVisibility (Plots.Axis.Labels.AxisLabel b v n)
instance (Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.TwoD.Text.Text n) b) => Data.Default.Class.Default (Plots.Axis.Labels.AxisLabel b Linear.V2.V2 n)
instance Plots.Axis.Labels.HasTickLabels f (Plots.Axis.Labels.TickLabels b v n) b
instance (Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.TwoD.Text.Text n) b) => Data.Default.Class.Default (Plots.Axis.Labels.TickLabels b Linear.V2.V2 n)
instance Plots.Types.HasVisibility (Plots.Axis.Labels.TickLabels b v n)


-- | The lines that make up an axis.
module Plots.Axis.Line

-- | Information about position and style of axis lines.
data AxisLine v n

-- | Class of object that have an <a>AxisLine</a>.
class HasAxisLine f a where axisLineType = axisLine . lens alType (\ al sty -> al {alType = sty}) axisLineArrowOpts = axisLine . lens alArrowOpts (\ al sty -> al {alArrowOpts = sty}) axisLineVisible = axisLine . lens alVisible (\ al b -> al {alVisible = b}) axisLineStyle = axisLine . lens alStyle (\ al sty -> al {alStyle = sty})

-- | Lens onto the <a>AxisLine</a>.
axisLine :: HasAxisLine f a => LensLike' f a (AxisLine (V a) (N a))

-- | The position of the axis line around the axis.
--   
--   <a>Default</a> is <a>BoxAxisLine</a>.
axisLineType :: (HasAxisLine f a, Functor f) => LensLike' f a AxisLineType

-- | The options for if you want the axis line to have arrows at the end.
--   
--   <a>Default</a> is <a>Nothing</a>.
--   
--   XXX (feature not currently implimented)
axisLineArrowOpts :: (HasAxisLine f a, Functor f) => LensLike' f a (Maybe (ArrowOpts (N a)))

-- | Whether the axis line should be visible.
--   
--   Note this is different from <a>NoAxisLine</a>. Other parts that are
--   tied to the axis line will still be present when
--   <a>axisLineVisible</a> is <a>False</a>. But if <a>NoAxisLine</a> is
--   set, there never any line for those things to attach to, so they don't
--   exist.
--   
--   <a>Default</a> is <a>True</a>.
axisLineVisible :: (HasAxisLine f a, Functor f) => LensLike' f a Bool

-- | The <a>Style</a> applied to the axis line
axisLineStyle :: (HasAxisLine f a, Functor f) => LensLike' f a (Style (V a) (N a))

-- | Where axis line for coordinate should be drawn. The <a>Default</a> is
--   <a>BoxAxisLine</a>.
data AxisLineType
BoxAxisLine :: AxisLineType
LeftAxisLine :: AxisLineType
MiddleAxisLine :: AxisLineType
RightAxisLine :: AxisLineType
NoAxisLine :: AxisLineType
instance GHC.Classes.Eq Plots.Axis.Line.AxisLineType
instance GHC.Show.Show Plots.Axis.Line.AxisLineType
instance Data.Default.Class.Default Plots.Axis.Line.AxisLineType
instance Plots.Axis.Line.HasAxisLine f (Plots.Axis.Line.AxisLine v n)
instance Plots.Types.HasVisibility (Plots.Axis.Line.AxisLine v n)
instance Data.Typeable.Internal.Typeable n => Data.Default.Class.Default (Plots.Axis.Line.AxisLine v n)

module Plots.Legend

-- | The data type to describe how to draw a legend. For legend entries see
--   <a>LegendEntry</a>.
data Legend b n
class HasLegend a b | a -> b where legendPosition = legend . lens lPosition (\ l a -> l {lPosition = a}) legendAnchor = legend . lens lAnchor (\ l a -> l {lAnchor = a}) legendGap = legend . lens lGap (\ l a -> l {lGap = a}) legendStyle = legend . lens lStyle (\ l a -> l {lStyle = a}) legendSpacing = legend . lens lSpacing (\ l a -> l {lSpacing = a}) legendTextWidth = legend . lens lTextWidth (\ l a -> l {lTextWidth = a}) legendTextFunction = legend . lens lTextF (\ l a -> l {lTextF = a}) legendTextStyle = legend . lens lTextStyle (\ l a -> l {lTextStyle = a}) legendOrientation = legend . lens lOrientation (\ l a -> l {lOrientation = a}) legendVisible = legend . lens lVisible (\ l a -> l {lVisible = a})
legend :: HasLegend a b => Lens' a (Legend b (N a))

-- | The <a>Position</a> of the legend relative to the <a>Axis</a>.
legendPosition :: HasLegend a b => Lens' a Position

-- | The anchor for where the legend is placed.
legendAnchor :: HasLegend a b => Lens' a Anchor

-- | The gap between the legend and the axis.
legendGap :: HasLegend a b => Lens' a (V2 (N a))

-- | The style applied to the surronding box of the legend.
legendStyle :: HasLegend a b => Lens' a (Style V2 (N a))

-- | The spacing between entries in the legend.
legendSpacing :: HasLegend a b => Lens' a (N a)

-- | The space given for the text in the legend.
legendTextWidth :: HasLegend a b => Lens' a (N a)

-- | The function to generate the legend text.
legendTextFunction :: HasLegend a b => Lens' a (String -> QDiagram b V2 (N a) Any)

-- | The style applied to the legend text.
legendTextStyle :: HasLegend a b => Lens' a (Style V2 (N a))

-- | The way the legend entries are listed. (This will likely be replaced
--   by a grid-like system)
legendOrientation :: HasLegend a b => Lens' a Orientation

-- | Whether the legend should be visible.
legendVisible :: HasLegend a b => Lens' a Bool
data Position
North :: Position
NorthEast :: Position
East :: Position
SouthEast :: Position
South :: Position
SouthWest :: Position
West :: Position
NorthWest :: Position

-- | <tt>Position 0 0 = SouthWest</tt>, <tt>Position 1 1 = NorthWest</tt>
Position :: Rational -> Rational -> Position

-- | Get the point from the <a>Position</a> on the bounding box of the
--   enveloped object. Returns the origin if <tt>a</tt> has an empty
--   envelope.
getPosition :: (InSpace V2 n a, Enveloped a, HasOrigin a, Fractional n) => Position -> a -> P2 n
data Anchor
AnchorTop :: Anchor
AnchorTopRight :: Anchor
AnchorRight :: Anchor
AnchorBottomRight :: Anchor
AnchorBottom :: Anchor
AnchorBottomLeft :: Anchor
AnchorLeft :: Anchor
AnchorTopLeft :: Anchor

-- | <tt>Anchor 0 0 = AnchorBottomLeft</tt>, <tt>mkP2 1 1 =
--   AnchorTopRight</tt>
Anchor :: Rational -> Rational -> Anchor

-- | Align an object using a given anchor.
anchor :: (InSpace V2 n a, Alignable a, HasOrigin a, Floating n) => Anchor -> a -> a

-- | A tool for aligned one object to another.
alignTo :: (InSpace V2 n a, SameSpace a b, Enveloped a, HasOrigin a, Alignable b, HasOrigin b, Floating n) => Position -> a -> Anchor -> V2 n -> b -> b

-- | Draw a legend to the bounding box using the legend entries and legend
--   options.
drawLegend :: (TypeableFloat n, Typeable b, Renderable (Path V2 n) b, Renderable (Text n) b) => BoundingBox V2 n -> [(QDiagram b V2 n Any, String)] -> Legend b n -> QDiagram b V2 n Any
instance GHC.Classes.Ord Plots.Legend.Anchor
instance GHC.Classes.Eq Plots.Legend.Anchor
instance GHC.Read.Read Plots.Legend.Anchor
instance GHC.Show.Show Plots.Legend.Anchor
instance GHC.Classes.Ord Plots.Legend.Position
instance GHC.Classes.Eq Plots.Legend.Position
instance GHC.Read.Read Plots.Legend.Position
instance GHC.Show.Show Plots.Legend.Position
instance Plots.Legend.HasLegend (Plots.Legend.Legend b n) b
instance (Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.TwoD.Text.Text n) b) => Data.Default.Class.Default (Plots.Legend.Legend b n)
instance Plots.Types.HasVisibility (Plots.Legend.Legend b n)
instance Diagrams.Core.Types.TypeableFloat n => Diagrams.Core.Style.HasStyle (Plots.Legend.Legend b n)
instance Plots.Types.HasOrientation (Plots.Legend.Legend b n)


-- | XXX This module in unfinished and features in it may not work.
module Plots.Axis.ColourBar

-- | Options for drawing a colour bar. Note that for an axis, the
--   <a>ColourMap</a> is stored in the <a>AxisStyle</a>. These options are
--   for other aspects of the bar, not the colours used.
data ColourBar b n
ColourBar :: Orientation -> Bool -> MajorTicks V2 n -> V2 n -> n -> Style V2 n -> ColourBar b n
[cbOrientation] :: ColourBar b n -> Orientation
[cbVisible] :: ColourBar b n -> Bool
[cbMajorTicks] :: ColourBar b n -> MajorTicks V2 n
[cbExtent] :: ColourBar b n -> V2 n
[cbGap] :: ColourBar b n -> n
[cbStyle] :: ColourBar b n -> Style V2 n
defColourBar :: (Renderable (Text n) b, Renderable (Path V2 n) b, TypeableFloat n, Enum n) => ColourBar b n
class HasColourBar a b | a -> b where colourBarVisible = colourBar . lens cbVisible (\ c a -> c {cbVisible = a}) colourBarExtent = colourBar . lens cbExtent (\ c a -> c {cbExtent = a}) colourBarGap = colourBar . lens cbGap (\ c a -> c {cbGap = a}) colourBarStyle = colourBar . lens cbStyle (\ c a -> c {cbStyle = a})

-- | Lens onto the <a>ColourBar</a>.
colourBar :: HasColourBar a b => Lens' a (ColourBar b (N a))

-- | Whether the colour bar should be visible when rendering.
colourBarVisible :: HasColourBar a b => Lens' a Bool

-- | The size of the colour bar when it's in a <a>Horizontal</a>
--   <a>orientation</a>.
colourBarExtent :: HasColourBar a b => Lens' a (V2 (N a))

-- | Gap between the axis and the colour bar (if rendered with an axis).
colourBarGap :: HasColourBar a b => Lens' a (N a)

-- | Style used for the outline of a colour bar.
colourBarStyle :: HasColourBar a b => Lens' a (Style V2 (N a))

-- | Draw a standalone colour bar.
drawColourBar :: (TypeableFloat n, Renderable (Path V2 n) b) => ColourBar b n -> ColourMap -> (n, n) -> QDiagram b V2 n Any

-- | Add a colour bar to an object, using the bounding box for the object.
addColourBar :: (TypeableFloat n, Renderable (Path V2 n) b) => BoundingBox V2 n -> ColourBar b n -> ColourMap -> (n, n) -> QDiagram b V2 n Any
instance Plots.Axis.ColourBar.HasColourBar (Plots.Axis.ColourBar.ColourBar b n) b
instance Plots.Types.HasOrientation (Plots.Axis.ColourBar.ColourBar b n)
instance Data.Typeable.Internal.Typeable n => Diagrams.Core.Style.HasStyle (Plots.Axis.ColourBar.ColourBar b n)
instance Plots.Types.HasVisibility (Plots.Axis.ColourBar.ColourBar b n)


-- | The <a>Axis</a> is the main data type for "plots". It holds all the
--   nessesary infomation to be rendered into a <a>Diagram</a>.
module Plots.Axis

-- | Axis is the data type that holds all the nessessary information to
--   render a plot. Common <a>LensLike</a>s used for the axis (see
--   haddock's instances for a more comprehensive list):
--   
--   <ul>
--   <li><a>axisStyle</a> - customise the <a>AxisStyle</a></li>
--   <li><a>legend</a> - customise the <a>Legend</a></li>
--   <li><a>colourBar</a> - customise the <a>ColourBar</a></li>
--   <li><a>currentPlots</a> - current plots in the <a>Axis</a></li>
--   <li><a>finalPlots</a> - changes to the plots just before
--   rendering</li>
--   <li><a>axes</a> - changes to each
--   <a>SingleAxis</a><ul><li><a>xAxis</a> - the
--   x-axis</li><li><a>yAxis</a> - the y-axis</li><li><a>zAxis</a> - the
--   z-axis</li></ul></li>
--   </ul>
--   
--   The following <a>LensLike</a>s can be used on the on all the axes by
--   applying it the to <a>Axis</a> or can be used on a <a>SingleAxis</a>
--   by using it in combination with a specific axis (like <a>xAxis</a>).
--   
--   <ul>
--   <li><a>axisLabel</a> - customise the <a>MinorTicks</a></li>
--   <li><a>tickLabel</a> - customise the <a>TickLabels</a></li>
--   <li><a>minorTicks</a> - customise the <a>MinorTicks</a></li>
--   <li><a>majorTicks</a> - customise the <a>MajorTicks</a></li>
--   <li><a>gridLines</a> - customise the <a>GridLines</a></li>
--   <li><a>axisLine</a> - customise the <a>AxisLine</a></li>
--   <li><a>axisScaling</a> - customise the <a>AxisScaling</a></li>
--   </ul>
data Axis b c n

-- | Lens onto the separate axes of an axis. Allows changing the coordinate
--   system as long as the <a>BaseSpace</a> is the same.
--   
--   <pre>
--   <a>axes</a> :: <a>Lens'</a> (<a>Axis</a> b c n) (c (<a>SingleAxis</a> b v n))
--   </pre>
axes :: (v ~ BaseSpace c, v ~ BaseSpace c') => Lens (Axis b c n) (Axis b c' n) (c (SingleAxis b v n)) (c' (SingleAxis b v n))

-- | The list of plots currently in the axis.
axisPlots :: BaseSpace c ~ v => Lens' (Axis b c n) [DynamicPlot b v n]

-- | Traversal over the current plots in the axis.
currentPlots :: BaseSpace c ~ v => Traversal' (Axis b c n) (DynamicPlot b v n)

-- | Setter over the final plot before the axis is rendered.
--   
--   For example, to make all <tt>ScatterPlot</tt>s in the axis use a
--   <tt>connectingLine</tt>, you can add
--   
--   <pre>
--   <a>finalPlots</a> . <tt>connectingLine</tt> .= <a>True</a>
--   </pre>
--   
--   at the begining of the axis and all scatter plots added will have a
--   <tt>connectingLine</tt>.
finalPlots :: BaseSpace c ~ v => Setter' (Axis b c n) (DynamicPlot b v n)

-- | The size used for the rendered axis.
axisSize :: (HasLinearMap c, Num n, Ord n) => Lens' (Axis b c n) (SizeSpec c n)

-- | The default axis for plots in the <a>V2</a> coordinate system.
r2Axis :: (TypeableFloat n, Enum n, Renderable (Text n) b, Renderable (Path V2 n) b) => Axis b V2 n

-- | This family is used so that we can say (Axis Polar) but use V2 for the
--   underlying diagram.

-- | Add a <a>Plotable</a> <a>Plot</a> to an <a>Axis</a>.
addPlot :: (InSpace (BaseSpace c) n p, MonadState (Axis b c n) m, Plotable p b) => Plot p b -> m ()

-- | Add something <a>Plotable</a> to the <a>Axis</a> with a statefull
--   modification of the <a>Plot</a>.
addPlotable :: (InSpace (BaseSpace c) n p, MonadState (Axis b c n) m, Plotable p b) => p -> State (Plot p b) () -> m ()

-- | Simple version of <tt>AddPlotable</tt> without any changes
--   <a>Plot</a>.
addPlotable' :: (InSpace (BaseSpace v) n p, MonadState (Axis b v n) m, Plotable p b) => p -> m ()

-- | Render infomation for a single axis line.
data SingleAxis b v n

-- | Lens onto the x-axis of an <a>Axis</a>.
xAxis :: R1 c => Lens' (Axis b c n) (SingleAxis b (BaseSpace c) n)

-- | The label for the x-axis. Shorthand for <tt><a>xAxis</a> .
--   <a>axisLabelText</a></tt>.
xAxisLabel :: R1 c => Lens' (Axis b c n) String

-- | The minimum x value for the axis. If the value if <a>Nothing</a> (the
--   <a>Default</a>), the bounds will be infered by the plots in the axis.
xMin :: R1 c => Lens' (Axis b c n) (Maybe n)

-- | The minimum x value for the axis. If the value if <a>Nothing</a> (the
--   <a>Default</a>), the bounds will be infered by the plots in the axis.
xMax :: R1 c => Lens' (Axis b c n) (Maybe n)

-- | Lens onto the y-axis of an <a>Axis</a>.
yAxis :: R2 c => Lens' (Axis b c n) (SingleAxis b (BaseSpace c) n)

-- | The label for the y-axis. Shorthand for <tt><a>yAxis</a> .
--   <a>axisLabelText</a></tt>.
yAxisLabel :: R2 c => Lens' (Axis b c n) String

-- | The minimum y value for the axis. If the value if <a>Nothing</a> (the
--   <a>Default</a>), the bounds will be infered by the plots in the axis.
yMin :: R2 c => Lens' (Axis b c n) (Maybe n)

-- | The minimum y value for the axis. If the value if <a>Nothing</a> (the
--   <a>Default</a>), the bounds will be infered by the plots in the axis.
yMax :: R2 c => Lens' (Axis b c n) (Maybe n)

-- | Lens onto the z-axis of an <a>Axis</a>.
zAxis :: R3 c => Lens' (Axis b c n) (SingleAxis b (BaseSpace c) n)

-- | The label for the z-axis. Shorthand for <tt><a>zAxis</a> .
--   <a>axisLabelText</a></tt>.
zAxisLabel :: R3 c => Lens' (Axis b c n) String

-- | The minimum z value for the axis. If the value if <a>Nothing</a> (the
--   <a>Default</a>), the bounds will be infered by the plots in the axis.
zMin :: R3 c => Lens' (Axis b c n) (Maybe n)

-- | The minimum z value for the axis. If the value if <a>Nothing</a> (the
--   <a>Default</a>), the bounds will be infered by the plots in the axis.
zMax :: R3 c => Lens' (Axis b c n) (Maybe n)
instance (Diagrams.Core.Types.TypeableFloat n, GHC.Enum.Enum n, Diagrams.Core.Types.Renderable (Diagrams.TwoD.Text.Text n) b) => Data.Default.Class.Default (Plots.Axis.SingleAxis b Linear.V2.V2 n)
instance GHC.Base.Functor f => Plots.Axis.Ticks.HasTicks f (Plots.Axis.SingleAxis b v n)
instance GHC.Base.Functor f => Plots.Axis.Ticks.HasMajorTicks f (Plots.Axis.SingleAxis b v n)
instance GHC.Base.Functor f => Plots.Axis.Ticks.HasMinorTicks f (Plots.Axis.SingleAxis b v n)
instance GHC.Base.Functor f => Plots.Axis.Labels.HasAxisLabel f (Plots.Axis.SingleAxis b v n) b
instance GHC.Base.Functor f => Plots.Axis.Labels.HasTickLabels f (Plots.Axis.SingleAxis b v n) b
instance GHC.Base.Functor f => Plots.Axis.Line.HasAxisLine f (Plots.Axis.SingleAxis b v n)
instance GHC.Base.Functor f => Plots.Axis.Grid.HasGridLines f (Plots.Axis.SingleAxis b v n)
instance GHC.Base.Functor f => Plots.Axis.Scale.HasAxisScaling f (Plots.Axis.SingleAxis b v n)
instance (GHC.Base.Applicative f, Data.Traversable.Traversable c) => Plots.Axis.Ticks.HasTicks f (Plots.Axis.Axis b c n)
instance (GHC.Base.Applicative f, Data.Traversable.Traversable c) => Plots.Axis.Ticks.HasMajorTicks f (Plots.Axis.Axis b c n)
instance (GHC.Base.Applicative f, Data.Traversable.Traversable c) => Plots.Axis.Ticks.HasMinorTicks f (Plots.Axis.Axis b c n)
instance (GHC.Base.Applicative f, Data.Traversable.Traversable c) => Plots.Axis.Grid.HasGridLines f (Plots.Axis.Axis b c n)
instance (GHC.Base.Applicative f, Data.Traversable.Traversable c) => Plots.Axis.Labels.HasAxisLabel f (Plots.Axis.Axis b c n) b
instance (GHC.Base.Applicative f, Data.Traversable.Traversable c) => Plots.Axis.Labels.HasTickLabels f (Plots.Axis.Axis b c n) b
instance (GHC.Base.Applicative f, Data.Traversable.Traversable c) => Plots.Axis.Scale.HasAxisScaling f (Plots.Axis.Axis b c n)
instance Control.Lens.Internal.Setter.Settable f => Plots.Style.HasPlotStyle f (Plots.Axis.Axis b c n) b
instance Plots.Legend.HasLegend (Plots.Axis.Axis b c n) b
instance Plots.Style.HasAxisStyle (Plots.Axis.Axis b v n) b
instance Plots.Axis.ColourBar.HasColourBar (Plots.Axis.Axis b v n) b


-- | A scatter plot is a type of mathematical diagram using Cartesian
--   coordinates to display values for typically two variables for a set of
--   data.
module Plots.Types.Scatter

-- | A general data type for scatter plots. Allows storing different types
--   of data as well as allowing transforms depending on the data.
data ScatterPlot v n

-- | A general data type for scatter plots. Allows storing different types
--   of data as well as allowing transforms depending on the data.
data ScatterOptions v n a
class HasScatterOptions f a d where scatterTransform = gscatterOptions . lens oTr (\ o tr -> o {oTr = tr}) scatterStyle = gscatterOptions . lens oSty (\ o sty -> o {oSty = sty}) scatterPosition = gscatterOptions . lens oPos (\ o pos -> o {oPos = pos})

-- | Lens onto the <a>ScatterOptions</a> for a general scatter plot.
gscatterOptions :: HasScatterOptions f a d => LensLike' f a (ScatterOptions (V a) (N a) d)

-- | Apply a transform to the markers using the associated data.
scatterTransform :: (HasScatterOptions f a d, Functor f) => LensLike' f a (d -> Transformation (V a) (N a))

-- | Apply a style to the markers using the associated data.
scatterStyle :: (HasScatterOptions f a d, Functor f) => LensLike' f a (d -> Style (V a) (N a))

-- | Change the position of the markers depending on the data.
scatterPosition :: (HasScatterOptions f a d, Functor f) => LensLike' f a (d -> Point (V a) (N a))

-- | Class of things that have a <a>LensLike</a> for a <a>ScatterPlot</a>
--   's connecting line.
class HasConnectingLine f a

-- | <a>LensLike</a> onto whether the scatter plot should have a connecting
--   line between points. If the line is present, it uses the
--   <a>lineStyle</a> from the <a>PlotStyle</a>.
connectingLine :: (HasConnectingLine f a, Functor f) => LensLike' f a Bool

-- | Add a <a>ScatterPlot</a> to the <tt>AxisState</tt> from a data set.
--   
--   <pre>
--   myaxis = r2Axis ~&amp;
--     scatterPlot data1
--   </pre>
--   
--   <h3><b>Example</b></h3>
--   
--   
--   <pre>
--   mydata1 = [(1,3), (2,5.5), (3.2, 6), (3.5, 6.1)]
--   mydata2 = mydata1 &amp; each . _1 *~ 0.5
--   mydata3 = [V2 1.2 2.7, V2 2 5.1, V2 3.2 2.6, V2 3.5 5]
--   
--   myaxis :: Axis B V2 Double
--   myaxis = r2Axis &amp;~ do
--     scatterPlot mydata1 $ key "data 1"
--     scatterPlot mydata2 $ key "data 2"
--     scatterPlot mydata3 $ key "data 3"
--   </pre>
scatterPlot :: (BaseSpace c ~ v, PointLike v n p, Typeable n, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b, Foldable f) => f p -> State (Plot (ScatterOptions v n (Point v n)) b) () -> m ()

-- | Version of <a>scatterPlot</a> without any changes to the
--   <a>ScatterOptions</a>.
scatterPlot' :: (BaseSpace c ~ v, PointLike v n p, Typeable n, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b, Foldable f) => f p -> m ()

-- | Version of <a>scatterPlot</a> that accepts a <a>Fold</a> over the
--   data.
scatterPlotOf :: (BaseSpace c ~ v, PointLike v n p, Typeable n, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b) => Fold s p -> s -> State (Plot (ScatterOptions v n (Point v n)) b) () -> m ()

-- | Version of <a>scatterPlot</a> that accepts a <a>Fold</a> over the data
--   without any changes to the <a>ScatterOptions</a>.
scatterPlotOf' :: (BaseSpace c ~ v, PointLike v n p, Typeable n, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b) => Fold s p -> s -> m ()

-- | Lens onto a scatter plot of points.
scatterOptions :: (InSpace v n a, HasScatterOptions f a (Point v n)) => LensLike' f a (ScatterOptions v n (Point v n))

-- | Scatter plots with extra numeric parameter. By default the extra
--   parameter is the scale of the marker but this can be changed.
bubblePlot :: (BaseSpace c ~ v, PointLike v n p, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b, Typeable n, Foldable f) => f (n, p) -> State (Plot (BubbleOptions v n) b) () -> m ()

-- | Simple version of <a>bubblePlot</a> without any changes to the
--   <a>Plot</a>.
bubblePlot' :: (v ~ BaseSpace c, PointLike v n p, Typeable n, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b, Foldable f) => f (n, p) -> m ()

-- | Version of <a>bubblePlot</a> using a <a>Fold</a> over the data.
bubblePlotOf :: (BaseSpace c ~ v, PointLike v n p, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b, Typeable n) => Fold s (n, p) -> s -> State (Plot (BubbleOptions v n) b) () -> m ()

-- | Version of <a>bubblePlot</a> using a <a>Fold</a> over the data without
--   any changes to the <a>BubbleOptions</a>.
bubblePlotOf' :: (BaseSpace c ~ v, PointLike v n p, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b, Typeable n) => Fold s (n, p) -> s -> State (Plot (BubbleOptions v n) b) () -> m ()

-- | A bubble plot is a scatter plot using point together with a scalar.
type BubbleOptions v n = ScatterOptions v n (n, Point v n)

-- | LensLike onto into a <a>ScatterOptions</a> made up of a scaler
--   <tt>n</tt>, and a point, <tt><a>Point</a> v n</tt>
--   
--   <pre>
--   <a>bubbleOptions</a> :: <a>Lens'</a> (<a>Plot</a> (<a>BubbleOptions</a> v n) v) (<a>BubbleOptions</a> v n)
--   </pre>
bubbleOptions :: (InSpace v n a, HasScatterOptions f a (n, Point v n)) => LensLike' f a (BubbleOptions v n)

-- | Setter over the transform function for a <a>bubblePlot</a>. Default is
--   <a>scale</a>.
--   
--   <pre>
--   <a>bubbleOptions</a> :: <a>Setter'</a> (<a>Plot</a> (<a>BubbleOptions</a> v n) v) (n -&gt; <a>Transformation</a> v n)
--   </pre>
--   
--   Note that this is the less general version of <tt><a>bubblePlot</a> .
--   <a>scatterTransform</a></tt>, which would give a <a>LensLike</a> onto
--   <tt>(n, <a>Point</a> v n) -&gt; <a>Transformation</a> v n</tt>.
bubbleTransform :: (InSpace v n a, HasScatterOptions f a (n, Point v n), Settable f) => LensLike' f a (n -> Transformation v n)

-- | Setter over the style function for a <a>bubblePlot</a>. Default is
--   <a>mempty</a>.
--   
--   <pre>
--   <a>bubbleStyle</a> :: <a>Setter'</a> (<a>Plot</a> (<a>BubbleOptions</a> v n) v) (n -&gt; <a>Style</a> v n)
--   </pre>
--   
--   Note that this is the less general version of <tt><a>bubblePlot</a> .
--   <a>scatterTransform</a></tt>, which would give a <a>LensLike</a> onto
--   <tt>(n, <a>Point</a> v n) -&gt; <a>Style</a> v n</tt>.
bubbleStyle :: (InSpace v n a, Settable f, HasScatterOptions f a (n, Point v n)) => LensLike' f a (n -> Style v n)

-- | A general scatter plot allow using any data type <tt>d</tt> to
--   determine the <a>scatterTransform</a> and <a>scatterStyle</a>.
gscatterPlot :: (BaseSpace c ~ v, PointLike v n p, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b, Typeable d, Foldable f) => f d -> (d -> p) -> State (Plot (ScatterOptions v n d) b) () -> m ()

-- | Helper to traverse over a general scatter plot where the type of d is
--   not infered.
gscatterOptionsFor :: (InSpace v n a, HasScatterOptions f a d) => proxy d -> LensLike' f a (ScatterOptions v n d)

-- | Low level construction of <a>ScatterOptions</a>.
mkScatterOptions :: (PointLike v n p, Foldable f, Fractional n) => f a -> (a -> p) -> ScatterOptions v n a
instance (Linear.Metric.Metric v, Diagrams.Core.Envelope.OrderedField n) => Diagrams.Core.Envelope.Enveloped (Plots.Types.Scatter.ScatterPlot v n)
instance (Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.Scatter.ScatterPlot Linear.V2.V2 n) b
instance Plots.Types.Scatter.HasConnectingLine f (Plots.Types.Scatter.ScatterOptions v n a)
instance Plots.Types.Scatter.HasConnectingLine f (Plots.Types.Scatter.ScatterPlot v n)
instance Plots.Types.Scatter.HasConnectingLine f p => Plots.Types.Scatter.HasConnectingLine f (Plots.Types.Plot p b)
instance (GHC.Base.Applicative f, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable v, Data.Typeable.Internal.Typeable n) => Plots.Types.Scatter.HasConnectingLine f (Plots.Types.DynamicPlot b v n)
instance (GHC.Base.Applicative f, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable (Plots.Axis.BaseSpace c), Data.Typeable.Internal.Typeable n) => Plots.Types.Scatter.HasConnectingLine f (Plots.Axis.Axis b c n)
instance (d ~ d') => Plots.Types.Scatter.HasScatterOptions f (Plots.Types.Scatter.ScatterOptions v n d) d'
instance (GHC.Base.Applicative f, Data.Typeable.Internal.Typeable v, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable d) => Plots.Types.Scatter.HasScatterOptions f (Plots.Types.Scatter.ScatterPlot v n) d
instance (GHC.Base.Functor f, Plots.Types.Scatter.HasScatterOptions f p a) => Plots.Types.Scatter.HasScatterOptions f (Plots.Types.Plot p b) a
instance (GHC.Base.Applicative f, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable v, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable a) => Plots.Types.Scatter.HasScatterOptions f (Plots.Types.DynamicPlot b v n) a
instance (GHC.Base.Applicative f, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable (Plots.Axis.BaseSpace c), Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable a) => Plots.Types.Scatter.HasScatterOptions f (Plots.Axis.Axis b c n) a

module Plots.Types.Line

-- | Construct a localed trail from a list of folable of points.
mkTrail :: (PointLike v n p, OrderedField n, Foldable f) => f p -> Located (Trail v n)

-- | Construct a localed trail from a fold over points.
mkTrailOf :: (PointLike v n p, OrderedField n) => Fold s p -> s -> Located (Trail v n)

-- | Construct a localed trail from a fold over points.
mkPath :: (PointLike v n p, OrderedField n, Foldable f, Foldable g) => g (f p) -> Path v n

-- | Construct a localed trail from a fold over points.
mkPathOf :: (PointLike v n p, OrderedField n) => Fold s t -> Fold t p -> s -> Path v n
data GLinePlot v n a

-- | Plot a general line plot give a fold
mkGLinePlotOf :: (PointLike v n p, Fractional n) => Fold s a -> s -> (a -> p) -> GLinePlot v n a

-- | Plot a general line plot.
mkGLinePlot :: (PointLike v n p, Foldable f, Fractional n) => f a -> (a -> p) -> GLinePlot v n a
type LinePlot v n = GLinePlot v n (Point v n)

-- | Make a line plot using the given fold.
mkLinePlotOf :: (PointLike v n p, Num n) => Fold s p -> s -> LinePlot v n

-- | Make a line plot.
mkLinePlot :: (PointLike v n p, Foldable f, Num n) => f p -> LinePlot v n

-- | Create a data for step plots.
createStepData :: [(a, a)] -> [(a, a)]
dotsonPoint :: HasPath a v n d => Lens' a Bool
pathStyle :: HasPath a v n d => Lens' a (Maybe (d -> Style V2 n))
linePlot :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (LinePlot v n) b, Foldable f) => f p -> State (Plot (LinePlot v n) b) () -> m ()

-- | Make a <a>LinePlot</a> and take a <a>State</a> on the plot to alter
--   it's options
linePlot' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (LinePlot v n) b, Foldable f) => f p -> m ()

-- | Add a <a>LinePlot</a> with the given name for the legend entry.
--   
--   <pre>
--   myaxis = r2Axis &amp;~ do
--     linePlotL "blue team" pointData1
--     linePlotL "red team" pointData2
--   </pre>
--   
--   linePlotL :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c
--   n) m, Plotable (LinePlot v n) b, F.Foldable f) =&gt; String -&gt; f p
--   -&gt; m () linePlotL l d = addPlotableL l (mkLinePlot d)
--   
--   mkTrail version of line plot
linePlotOf :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (LinePlot v n) b) => Fold s p -> s -> State (Plot (LinePlot v n) b) () -> m ()
linePlotOf' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (LinePlot v n) b) => Fold s p -> s -> m ()
stepPlot :: (RealFloat n, Typeable n, Typeable b, Renderable (Path V2 n) b, MonadState (Axis b c n) m, BaseSpace c ~ V2) => [(n, n)] -> State (Plot (LinePlot V2 n) b) () -> m ()
stepPlot' :: (RealFloat n, Typeable n, Typeable b, Renderable (Path V2 n) b, MonadState (Axis b c n) m, BaseSpace c ~ V2) => [(n, n)] -> m ()
glinePlot :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (GLinePlot v n a) b, Foldable f) => f a -> (a -> p) -> State (Plot (GLinePlot v n a) b) () -> m ()
glinePlot' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (GLinePlot v n a) b, Foldable f) => f a -> (a -> p) -> m ()
instance (Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Diagrams.Path.Path Linear.V2.V2 n) b
instance (Linear.Metric.Metric v, Diagrams.Core.Envelope.OrderedField n) => Diagrams.Core.Envelope.Enveloped (Plots.Types.Line.GLinePlot v n a)
instance (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.Line.GLinePlot Linear.V2.V2 n a) b
instance Plots.Types.Line.HasPath (Plots.Types.Line.GLinePlot v n d) v n d
instance Plots.Types.Line.HasPath (Plots.Types.Plot (Plots.Types.Line.GLinePlot v n d) b) v n d

module Plots.Types.Ribbon
data GRibbonPlot v n a
type RibbonPlot v n = GRibbonPlot v n (Point v n)

-- | Make a line plot using the given fold.
mkRibbonPlotOf :: (PointLike v n p, Num n) => Fold s p -> s -> RibbonPlot v n

-- | Make a line plot.
mkRibbonPlot :: (PointLike v n p, Foldable f, Num n) => f p -> RibbonPlot v n
createBarData :: (Fractional t, Num t) => (t, t) -> t -> [(t, t)]
strokeEdge :: HasRibbon a v n d => Lens' a Bool
ribbonPlot :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (RibbonPlot v n) b, Foldable f) => f p -> State (Plot (RibbonPlot v n) b) () -> m ()
ribbonPlot' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (RibbonPlot v n) b, Foldable f) => f p -> m ()
ribbonPlotOf :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (RibbonPlot v n) b) => Fold s p -> s -> State (Plot (RibbonPlot v n) b) () -> m ()
ribbonPlotOf' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (RibbonPlot v n) b) => Fold s p -> s -> m ()
instance (Linear.Metric.Metric v, Diagrams.Core.Envelope.OrderedField n) => Diagrams.Core.Envelope.Enveloped (Plots.Types.Ribbon.GRibbonPlot v n a)
instance (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.Ribbon.GRibbonPlot Linear.V2.V2 n a) b
instance Plots.Types.Ribbon.HasRibbon (Plots.Types.Ribbon.GRibbonPlot v n d) v n d
instance Plots.Types.Ribbon.HasRibbon (Plots.Types.Plot (Plots.Types.Ribbon.GRibbonPlot v n d) b) v n d


module Plots.Types.Histogram

-- | Simple histogram type supporting uniform bins.
data HistogramPlot n

-- | Plot an already computed histogram with equally sized bins.
computedHistogram :: (MonadState (Axis b V2 n) m, Plotable (HistogramPlot n) b, Foldable f, Typeable b, TypeableFloat n) => n -> n -> f n -> State (Plot (HistogramPlot n) b) () -> m ()

-- | Options for binning histogram data. For now only very basic histograms
--   building is supported.
data HistogramOptions n
class HasOrientation a => HasHistogramOptions a where numBins = histogramOptions . lens hBins (\ ho n -> ho {hBins = n}) binRange = histogramOptions . lens hRange (\ ho r -> ho {hRange = r}) normaliseSample = histogramOptions . lens hNorm (\ ho b -> ho {hNorm = b})

-- | Options for building the histogram from data.
histogramOptions :: HasHistogramOptions a => Lens' a (HistogramOptions (N a))

-- | The number of bins (bars) to use for the histogram. Must be positive.
--   
--   <a>Default</a> is <tt>10</tt>.
numBins :: HasHistogramOptions a => Lens' a Int

-- | The range of data to consider when building the histogram. Any data
--   outside the range is ignored.
--   
--   <a>Default</a> is <a>Nothing</a>.
binRange :: HasHistogramOptions a => Lens' a (Maybe (N a, N a))

-- | Should the resulting histogram be normalised so the total area is 1.
--   
--   <a>Default</a> is False.
normaliseSample :: HasHistogramOptions a => Lens' a NormalisationMethod

-- | The way to normalise the data from a histogram. The default method is
--   <a>count</a>.
data NormalisationMethod

-- | The height of each bar is the number of observations. This is the
--   <a>Default</a> method.
count :: NormalisationMethod

-- | The sum of the heights of the bars is equal to 1.
probability :: NormalisationMethod

-- | The height of each bar is <tt>n / w</tt> where <tt>n</tt> is the
--   number of observations and <tt>w</tt> is the width.
countDensity :: NormalisationMethod

-- | The total area of the bars is <tt>1</tt>. This gives a probability
--   density function estimate.
pdf :: NormalisationMethod

-- | The height of each bar is the cumulative number of observations in
--   each bin and all previous bins. The height of the last bar is the
--   total number of observations.
cumilative :: NormalisationMethod

-- | Cumulative density function estimate. The height of each bar is equal
--   to the cumulative relative number of observations in the bin and all
--   previous bins. The height of the last bar is 1.
cdf :: NormalisationMethod

-- | Add a <a>HistogramPlot</a> to the <tt>AxisState</tt> from a data set.
--   
--   <pre>
--   myaxis = r2Axis ~&amp;
--     histogramPlot data1
--   </pre>
--   
--   <h3><b>Example</b></h3>
--   
--   
--   <pre>
--   fillOpacity = barStyle . mapped . _opacity
--   
--   myaxis :: Axis B V2 Double
--   myaxis = r2Axis &amp;~ do
--    histogramPlot' mydata1 $ do
--       addLegendEntry "histogram"
--       plotColor .= blue
--       fillOpacity .= 0.5
--   </pre>
histogramPlot :: (MonadState (Axis b V2 n) m, Plotable (HistogramPlot n) b, Foldable f, RealFrac n) => f n -> State (Plot (HistogramOptions n) b) () -> m ()

-- | Make a <a>HistogramPlot</a> and take a <a>State</a> on the plot to
--   alter it's options
--   
--   <pre>
--   myaxis = r2Axis &amp;~ do
--     histogramPlot' pointData1 $ do
--       setBin .= 30
--       addLegendEntry "data 1"
--   </pre>
histogramPlot' :: (MonadState (Axis b V2 n) m, Plotable (HistogramPlot n) b, Foldable f, RealFrac n) => f n -> m ()

-- | Add a <a>HistogramPlot</a> using a fold over the data.
histogramPlotOf :: (MonadState (Axis b V2 n) m, Plotable (HistogramPlot n) b, RealFrac n) => Fold s n -> s -> State (Plot (HistogramOptions n) b) () -> m ()

-- | Same as <a>histogramPlotOf</a> without any changes to the plot.
histogramPlotOf' :: (MonadState (Axis b V2 n) m, Plotable (HistogramPlot n) b, RealFrac n) => Fold s n -> s -> m ()

-- | Construct a <a>HistogramPlot</a> from raw histogram data.
mkComputedHistogram :: (Foldable f, OrderedField n) => n -> n -> f n -> HistogramPlot n

-- | Create a histogram by binning the data using the
--   <a>HistogramOptions</a>.
mkHistogramPlot :: (Foldable f, RealFrac n) => HistogramOptions n -> f n -> HistogramPlot n
instance Diagrams.Core.Envelope.OrderedField n => Diagrams.Core.Envelope.Enveloped (Plots.Types.Histogram.HistogramPlot n)
instance (Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.Histogram.HistogramPlot n) b
instance Plots.Types.HasOrientation (Plots.Types.Histogram.HistogramPlot n)
instance Data.Default.Class.Default Plots.Types.Histogram.NormalisationMethod
instance Data.Default.Class.Default (Plots.Types.Histogram.HistogramOptions n)
instance Plots.Types.HasOrientation (Plots.Types.Histogram.HistogramOptions n)
instance Plots.Types.Histogram.HasHistogramOptions (Plots.Types.Histogram.HistogramOptions n)
instance Plots.Types.Histogram.HasHistogramOptions a => Plots.Types.Histogram.HasHistogramOptions (Plots.Types.Plot a b)

module Plots.Types.Function
data FunctionPlotOptions n
functionPlotNumPoints :: HasFunctionPlotOptions c_a2trM n_a2trn => Lens' c_a2trM Int
data ParametricPlot v n
ParametricPlot :: (n -> Point v n) -> (n, n) -> FunctionPlotOptions n -> ParametricPlot v n
[_parametricFunction] :: ParametricPlot v n -> n -> Point v n
[_parametricDomain] :: ParametricPlot v n -> (n, n)
[_parametricPlotOptions] :: ParametricPlot v n -> FunctionPlotOptions n

-- | Create a parametric plot given a function on range (0,5).
mkParametricPlot :: (PointLike v n p, Additive v, TypeableFloat n) => (n -> p) -> ParametricPlot v n
parametricDomain :: Lens' (ParametricPlot v_a2trW n_a2trX) (n_a2trX, n_a2trX)

-- | Create a parametric plot given a function and a range.
mkParametricRangePlot :: (PointLike v n p, Additive v, TypeableFloat n) => (n -> p) -> (n, n) -> ParametricPlot v n

-- | Functions to create ab, vertical and horizontal lines.
createABLine :: Num n => n -> n -> n -> P2 n
createHLine :: n -> n -> P2 n
createVLine :: n -> n -> P2 n
data VectorPlot v n
VectorPlot :: v n -> (n, n) -> ArrowOpts n -> VectorPlot v n
[_vectorV] :: VectorPlot v n -> v n
[_vectorPoint] :: VectorPlot v n -> (n, n)
[_vectorArrows] :: VectorPlot v n -> ArrowOpts n

-- | Plot a given vector at (0,0).
mkVectorPlot :: (Additive v, TypeableFloat n) => v n -> VectorPlot v n

-- | Plot a given vector at a given point.
mkVectorPointPlot :: (Additive v, TypeableFloat n) => v n -> (n, n) -> VectorPlot v n
setArrowOpts :: HasVector a v n => Lens' a (ArrowOpts n)
parametricPlot :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (ParametricPlot v n) b, Additive v, TypeableFloat n) => (n -> p) -> State (Plot (ParametricPlot v n) b) () -> m ()
parametricRangePlot :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (ParametricPlot v n) b, Additive v, TypeableFloat n) => (n -> p) -> (n, n) -> State (Plot (ParametricPlot v n) b) () -> m ()
parametricPlot' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (ParametricPlot v n) b, Additive v, TypeableFloat n) => (n -> p) -> m ()
parametricRangePlot' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (ParametricPlot v n) b, Additive v, TypeableFloat n) => (n -> p) -> (n, n) -> m ()
abLinePlot :: (v ~ BaseSpace c, PointLike v n (P2 n), MonadState (Axis b c n) m, Plotable (ParametricPlot v n) b, Additive v, TypeableFloat n) => n -> n -> (n, n) -> State (Plot (ParametricPlot v n) b) () -> m ()
hLinePlot :: (v ~ BaseSpace c, PointLike v n (P2 n), MonadState (Axis b c n) m, Plotable (ParametricPlot v n) b, Additive v, TypeableFloat n) => n -> (n, n) -> State (Plot (ParametricPlot v n) b) () -> m ()
vLinePlot :: (v ~ BaseSpace c, PointLike v n (P2 n), MonadState (Axis b c n) m, Plotable (ParametricPlot v n) b, Additive v, TypeableFloat n) => n -> (n, n) -> State (Plot (ParametricPlot v n) b) () -> m ()
vectorPlot :: (v ~ BaseSpace c, MonadState (Axis b c n) m, Plotable (VectorPlot v n) b, Additive v, TypeableFloat n) => v n -> State (Plot (VectorPlot v n) b) () -> m ()
vectorPointPlot :: (v ~ BaseSpace c, MonadState (Axis b c n) m, Plotable (VectorPlot v n) b, Additive v, TypeableFloat n) => v n -> (n, n) -> State (Plot (VectorPlot v n) b) () -> m ()
vectorPointPlot' :: (v ~ BaseSpace c, MonadState (Axis b c n) m, Plotable (VectorPlot v n) b, Additive v, TypeableFloat n) => v n -> (n, n) -> m ()
vectorPointPlot'' :: (v ~ BaseSpace c, MonadState (Axis b c n) m, Plotable (VectorPlot v n) b, Additive v, TypeableFloat n) => v n -> (n, n) -> ArrowOpts n -> m ()
vectorFieldPlot :: (v ~ BaseSpace c, MonadState (Axis b c n) m, Plotable (VectorPlot v n) b, Additive v, TypeableFloat n) => [v n] -> [(n, n)] -> ArrowOpts n -> m ()
instance (Linear.Metric.Metric v, Diagrams.Core.Envelope.OrderedField n, Diagrams.Core.Types.TypeableFloat n, GHC.Enum.Enum n) => Diagrams.Core.Envelope.Enveloped (Plots.Types.Function.VectorPlot v n)
instance (Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, GHC.Enum.Enum n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.Function.VectorPlot Linear.V2.V2 n) b
instance Plots.Types.Function.HasVector (Plots.Types.Function.VectorPlot v n) v n
instance Plots.Types.Function.HasVector (Plots.Types.Plot (Plots.Types.Function.VectorPlot v n) b) v n
instance Plots.Types.Function.HasFunctionPlotOptions (Plots.Types.Function.ParametricPlot v n) n
instance (Linear.Metric.Metric v, Diagrams.Core.Envelope.OrderedField n, Diagrams.Core.Types.TypeableFloat n, GHC.Enum.Enum n) => Diagrams.Core.Envelope.Enveloped (Plots.Types.Function.ParametricPlot v n)
instance (Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, GHC.Enum.Enum n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.Function.ParametricPlot Linear.V2.V2 n) b
instance Plots.Types.Function.HasFunctionPlotOptions (Plots.Types.Function.FunctionPlotOptions n0) n0
instance Data.Default.Class.Default (Plots.Types.Function.FunctionPlotOptions n)

module Plots.Types.Boxplot

-- | Add a <a>BoxPlot</a> to the <tt>AxisState</tt> from a data set.
--   
--   <pre>
--   myaxis = r2Axis &amp;~
--     boxPlot data1
--   </pre>
--   
--   <h3><b>Example</b></h3>
--   
--   
--   <pre>
--   mydata1 = [(1,3), (2,5.5), (3.2, 6), (3.5, 6.1)]
--   mydata2 = mydata1 &amp; each . _1 *~ 0.5
--   mydata3 = [V2 1.2 2.7, V2 2 5.1, V2 3.2 2.6, V2 3.5 5]
--   
--   myaxis :: Axis B V2 Double
--   myaxis = r2Axis &amp;~ do
--      boxPlot mydata1
--      boxPlot mydata2
--      boxPlot mydata3
--   </pre>
boxPlot :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (BoxPlot v n) b, Foldable f, Enum n, TypeableFloat n) => f p -> State (Plot (BoxPlot v n) b) () -> m ()

-- | Make a <a>BoxPlot</a> and take a <a>State</a> on the plot to alter its
--   options
--   
--   <pre>
--   myaxis = r2Axis &amp;~ do
--     boxPlot' pointData1 $ do
--       fillBox .= True
--       addLegendEntry "data 1"
--   </pre>
boxPlot' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (BoxPlot v n) b, Foldable f, Enum n, TypeableFloat n) => f p -> m ()

-- | Add a <a>BoxPlot</a> with the given name for the legend entry.
--   
--   <pre>
--   myaxis = r2Axis &amp;~ do
--     boxPlotL "blue team" pointData1
--     boxPlotL "red team" pointData2
--   </pre>
--   
--   boxPlotL :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n)
--   m, Plotable (BoxPlot v n) b, F.Foldable f , Enum n, TypeableFloat n)
--   =&gt; String -&gt; f p -&gt; m () boxPlotL l d = addPlotableL l
--   (mkBoxPlot d)
boxPlotOf :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (BoxPlot v n) b, Enum n, TypeableFloat n) => Fold s p -> s -> State (Plot (BoxPlot v n) b) () -> m ()
boxPlotOf' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (BoxPlot v n) b, Enum n, TypeableFloat n) => Fold s p -> s -> m ()
data GBoxPlot v n a
type BoxPlot v n = GBoxPlot v n (Point v n)

-- | Create a boxplot using a fold and given data.
mkBoxPlotOf :: (PointLike v n p, Ord n, Floating n, Enum n, Num n) => Fold s p -> s -> BoxPlot v n

-- | Draw a boxplot with the given data.
mkBoxPlot :: (PointLike v n p, Foldable f, Ord n, Floating n, Enum n, Num n) => f p -> BoxPlot v n
fillBox :: HasBox a v n d => Lens' a Bool
instance (Linear.Metric.Metric v, Diagrams.Core.Envelope.OrderedField n) => Diagrams.Core.Envelope.Enveloped (Plots.Types.Boxplot.GBoxPlot v n a)
instance (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b, GHC.Enum.Enum n, n ~ GHC.Types.Double) => Plots.Types.Plotable (Plots.Types.Boxplot.GBoxPlot Linear.V2.V2 n a) b
instance Plots.Types.Boxplot.HasBox (Plots.Types.Boxplot.GBoxPlot v n d) v n d
instance Plots.Types.Boxplot.HasBox (Plots.Types.Plot (Plots.Types.Boxplot.GBoxPlot v n d) b) v n d

module Plots.Types.Density
data GDensityPlot v n a
type DensityPlot v n = GDensityPlot v n (Point v n)

-- | Make a density plot using a given fold.
mkDensityPlotOf :: (PointLike v n p, Ord n, Floating n, Enum n, Num n) => Fold s p -> s -> DensityPlot v n

-- | Make a density plot.
mkDensityPlot :: (PointLike v n p, Foldable f, Ord n, Floating n, Enum n, Num n) => f p -> DensityPlot v n

-- | Function used to create the density, takes the average of the xdata,
--   bin y = 10.
densityY :: (Ord n, Floating n, Enum n) => [P2 n] -> Located (Trail' Line V2 n)
fillArea :: HasDensity a v n d => Lens' a Bool

-- | Add a <tt>DenistyPlot</tt> to the <tt>AxisState</tt> from a data set.
--   
--   <pre>
--   myaxis = r2Axis ~&amp;
--     densityPlot data1
--   </pre>
--   
--   <h3><b>Example</b></h3>
--   
--   
--   <pre>
--   myaxis :: Axis B V2 Double
--   myaxis = r2Axis &amp;~ do
--   
--       densityPlotL mydata1
--       densityPlotL mydata2
--       densityPlotL mydata3
--   </pre>
densityPlot :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (DensityPlot v n) b, Foldable f, Enum n, TypeableFloat n) => f p -> State (Plot (DensityPlot v n) b) () -> m ()

-- | Make a <a>DensityPlot</a> and take a <a>State</a> on the plot to alter
--   it's options
--   
--   <pre>
--   myaxis = r2Axis &amp;~ do
--     densityPlot' pointData1 $ do
--       fillArea .= True
--       addLegendEntry "data 1"
--   </pre>
densityPlot' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (DensityPlot v n) b, Foldable f, Enum n, TypeableFloat n) => f p -> m ()

-- | Add a <a>DensityPlot</a> with the given name for the legend entry.
--   
--   <pre>
--   myaxis = r2Axis &amp;~ do
--     densityPlotL "blue team" pointData1
--     densityPlotL "red team" pointData2
--   </pre>
densityPlotOf :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (DensityPlot v n) b, Enum n, TypeableFloat n) => Fold s p -> s -> State (Plot (DensityPlot v n) b) () -> m ()
densityPlotOf' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (DensityPlot v n) b, Enum n, TypeableFloat n) => Fold s p -> s -> m ()
instance (Linear.Metric.Metric v, Diagrams.Core.Envelope.OrderedField n) => Diagrams.Core.Envelope.Enveloped (Plots.Types.Density.GDensityPlot v n a)
instance (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b, GHC.Enum.Enum n) => Plots.Types.Plotable (Plots.Types.Density.GDensityPlot Linear.V2.V2 n a) b
instance Plots.Types.Density.HasDensity (Plots.Types.Density.GDensityPlot v n d) v n d
instance Plots.Types.Density.HasDensity (Plots.Types.Plot (Plots.Types.Density.GDensityPlot v n d) b) v n d

module Plots.Types.Smooth
data GSmoothPlot v n a
type SmoothPlot v n = GSmoothPlot v n (Point v n)

-- | Smooth plot with a given fold.
mkSmoothPlotOf :: (PointLike v n p, Ord n, Floating n, Enum n, Num n) => Fold s p -> s -> SmoothPlot v n

-- | Plot a smooth function given data.
mkSmoothPlot :: (PointLike v n p, Foldable f, Ord n, Floating n, Enum n, Num n) => f p -> SmoothPlot v n
drawTrail :: HasSmooth a v n d => Lens' a Bool
testXY :: (Ord n, Floating n, Enum n) => [P2 n] -> (Located (Trail' Loop V2 n), Located (Trail' Line V2 n))

-- | Add a <a>SmoothPlot</a> to the <tt>AxisState</tt> from a data set.
--   
--   <pre>
--   myaxis = r2Axis ~&amp;
--     smoothPlot data1
--   </pre>
--   
--   <h3><b>Example</b></h3>
--   
--   
--   <pre>
--   myaxis :: Axis B V2 Double
--   myaxis = r2Axis &amp;~ do
--      smoothPlot mydata1
--      smoothPlot mydata2
--      smoothPlot mydata3
--   </pre>
smoothPlot :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (SmoothPlot v n) b, Foldable f, Enum n, TypeableFloat n) => f p -> State (Plot (SmoothPlot v n) b) () -> m ()

-- | Make a <a>SmoothPlot</a> and take a <a>State</a> on the plot to alter
--   it's options
--   
--   <pre>
--   myaxis = r2Axis &amp;~ do
--     smoothPlot' pointData1 $ do
--       sLine .= False
--       addLegendEntry "data 1"
--   </pre>
smoothPlot' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (SmoothPlot v n) b, Foldable f, Enum n, TypeableFloat n) => f p -> m ()

-- | Add a <a>SmoothPlot</a> with the given name for the legend entry.
--   
--   <pre>
--   myaxis = r2Axis &amp;~ do
--     smoothPlotL "blue team" pointData1
--     smoothPlotL "red team" pointData2
--   </pre>
smoothPlotOf :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (SmoothPlot v n) b, Enum n, TypeableFloat n) => Fold s p -> s -> State (Plot (SmoothPlot v n) b) () -> m ()
smoothPlotOf' :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (SmoothPlot v n) b, Enum n, TypeableFloat n) => Fold s p -> s -> m ()
instance (Linear.Metric.Metric v, Diagrams.Core.Envelope.OrderedField n) => Diagrams.Core.Envelope.Enveloped (Plots.Types.Smooth.GSmoothPlot v n a)
instance (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.Smooth.GSmoothPlot Linear.V2.V2 n a) b
instance Plots.Types.Smooth.HasSmooth (Plots.Types.Smooth.GSmoothPlot v n d) v n d
instance Plots.Types.Smooth.HasSmooth (Plots.Types.Plot (Plots.Types.Smooth.GSmoothPlot v n d) b) v n d

module Plots.Types.Text
data TextPlot n

-- | Text alignment, font size, slant and weight
data TextOptions n

-- | Draw a given string at a given point.
mkTextPlot :: (TypeableFloat n, Fractional n) => (n, n) -> String -> TextPlot n
setOptions :: HasText a n => Lens' a (TextOptions n)
textPlot :: (v ~ BaseSpace c, RealFloat n, Typeable n, PointLike v n (V2 n), MonadState (Axis b c n) m, Plotable (TextPlot n) b, v ~ V2) => (n, n) -> String -> State (Plot (TextPlot n) b) () -> m ()
textPlot' :: (v ~ BaseSpace c, RealFloat n, Typeable n, PointLike v n (V2 n), MonadState (Axis b c n) m, Plotable (TextPlot n) b, v ~ V2) => (n, n) -> String -> m ()
tString :: Lens' (TextPlot n_a2P8H) String
textPoint :: Lens' (TextPlot n_a2P8H) (n_a2P8H, n_a2P8H)
textOptions :: Lens' (TextPlot n_a2P8H) (TextOptions n_a2P8H)
optalignment :: Lens' (TextOptions n_a2P8G) (n_a2P8G, n_a2P8G)
optfontSize :: Lens' (TextOptions n_a2P8G) n_a2P8G
optfontSlant :: Lens' (TextOptions n_a2P8G) FontSlant
optfontWeight :: Lens' (TextOptions n_a2P8G) FontWeight
instance (GHC.Real.Fractional n, Diagrams.Core.Envelope.OrderedField n, Diagrams.Core.Types.TypeableFloat n, GHC.Enum.Enum n) => Diagrams.Core.Envelope.Enveloped (Plots.Types.Text.TextPlot n)
instance (GHC.Real.Fractional n, Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, GHC.Enum.Enum n, Diagrams.Core.Types.Renderable (Diagrams.TwoD.Text.Text n) b, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.Text.TextPlot n) b
instance Plots.Types.Text.HasText (Plots.Types.Text.TextPlot n) n
instance Plots.Types.Text.HasText (Plots.Types.Plot (Plots.Types.Text.TextPlot n) b) n
instance GHC.Real.Fractional n => Data.Default.Class.Default (Plots.Types.Text.TextOptions n)

module Plots.Types.Pie
data GPiePlot n

-- | Plot a wedge given radius and angle with direction xDir.
mkWedgePlot :: (RealFloat n, PointLike v n (Polar n), Num n) => n -> Angle n -> GPiePlot n

-- | Plot a wedge given radius, angle and direction.
mkWedgePlotFrom :: (RealFloat n, PointLike v n (Polar n), Num n) => n -> Direction V2 n -> Angle n -> GPiePlot n

-- | Plot a annular wedge given radius, angle and direction.
mkAnnularWedgePlotFrom :: (RealFloat n, PointLike v n (Polar n), Num n) => n -> n -> Direction V2 n -> Angle n -> GPiePlot n

-- | Plot a annular wedge given radius and angle with direction xDir.
mkAnnularWedgePlot :: (RealFloat n, PointLike v n (Polar n), Num n) => n -> n -> Angle n -> GPiePlot n
strokeArc :: HasPie a n => Lens' a Bool

-- | Add a <tt>PiePlot</tt> to the <tt>AxisState</tt> from a data set.
--   
--   <pre>
--   myaxis = polarAxis ~&amp;
--     wedgePlot data1
--   </pre>
--   
--   <h3><b>Example</b></h3>
--   
--   
--   <pre>
--   myaxis = polarAxis &amp;~ do
--   
--       wedgePlotFrom' 7 xDir (2/11 @<tt> turn) $ do
--          strokeArc .= True
--          plotColor .= sRGB24  255 127 0
--       wedgePlotFrom' 4.3 (rotate (2/11 </tt><tt> turn) xDir) (4/11 </tt><tt> turn) $ do
--          strokeArc .= True
--          plotColor .=  sRGB24 166 86  40
--       wedgePlotFrom' 8.1 (rotate (6/11 </tt><tt> turn) xDir)  (3/11 </tt><tt> turn) $ do
--          strokeArc .= True
--          plotColor .= sRGB24 247 129 191
--       annularWedgePlotFrom' 3.1  0.1 (rotate (9/11 </tt><tt> turn) xDir)  (2/11 </tt><tt> turn) $ do
--          strokeArc .= True
--          plotColor .= sRGB24 117 69 69
--       annularWedgePlotFrom' 5.7  3.1 (rotate (9/11 </tt><tt> turn) xDir)  (2/11 </tt><tt> turn) $ do
--          strokeArc .= True
--          plotColor .= sRGB24 154 65 65
--       annularWedgePlotFrom' 9.5  5.7 (rotate (9/11 </tt><tt> turn) xDir)  (2/11 </tt>@ turn) $ do
--          strokeArc .= True
--          plotColor .= sRGB24 198  49   49
--   </pre>
wedgePlot :: (v ~ BaseSpace c, v ~ V2, PointLike v n (Polar n), MonadState (Axis b c n) m, Plotable (GPiePlot n) b, RealFloat n) => n -> Angle n -> State (Plot (GPiePlot n) b) () -> m ()
wedgePlotFrom :: (v ~ BaseSpace c, v ~ V2, PointLike v n (Polar n), MonadState (Axis b c n) m, Plotable (GPiePlot n) b, RealFloat n) => n -> Direction V2 n -> Angle n -> State (Plot (GPiePlot n) b) () -> m ()

-- | Make a wedge and take a <a>State</a> on the plot to alter it's options
wedgePlotFrom' :: (v ~ BaseSpace c, v ~ V2, PointLike v n (Polar n), MonadState (Axis b c n) m, Plotable (GPiePlot n) b, RealFloat n) => n -> Direction V2 n -> Angle n -> m ()
annularWedgePlot :: (v ~ BaseSpace c, v ~ V2, PointLike v n (Polar n), MonadState (Axis b c n) m, Plotable (GPiePlot n) b, RealFloat n) => n -> n -> Angle n -> State (Plot (GPiePlot n) b) () -> m ()
annularWedgePlotFrom :: (v ~ BaseSpace c, v ~ V2, PointLike v n (Polar n), MonadState (Axis b c n) m, Plotable (GPiePlot n) b, RealFloat n) => n -> n -> Direction V2 n -> Angle n -> State (Plot (GPiePlot n) b) () -> m ()

-- | Make an annular wedge and take a <a>State</a> on the plot to alter
--   it's options
annularWedgePlotFrom' :: (v ~ BaseSpace c, v ~ V2, PointLike v n (Polar n), MonadState (Axis b c n) m, Plotable (GPiePlot n) b, RealFloat n) => n -> n -> Direction V2 n -> Angle n -> m ()
instance Diagrams.Core.Envelope.OrderedField n => Diagrams.Core.Envelope.Enveloped (Plots.Types.Pie.GPiePlot n)
instance (Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.Pie.GPiePlot n) b
instance Plots.Types.Pie.HasPie (Plots.Types.Pie.GPiePlot n) n
instance Plots.Types.Pie.HasPie (Plots.Types.Plot (Plots.Types.Pie.GPiePlot n) b) n

module Plots.Types.Points
data GPointsPlot n

-- | Plot a polar scatter plot given a list of radius and angle.
mkPointsPlot :: (RealFloat n, PointLike V2 n (Polar n), Num n) => [(n, Angle n)] -> GPointsPlot n
doFill :: HasPoints a n => Lens' a Bool
pointsPlot :: (v ~ BaseSpace c, v ~ V2, PointLike v n (Polar n), MonadState (Axis b c n) m, Plotable (GPointsPlot n) b, RealFloat n) => [(n, Angle n)] -> State (Plot (GPointsPlot n) b) () -> m ()

-- | Make a <tt>PointsPlot</tt> and take a <a>State</a> on the plot to
--   alter it's options
--   
--   <pre>
--   myaxis = polarAxis &amp;~ do
--     pointsPlot' pointData1 $ do
--       addLegendEntry "data 1"
--       doFill .= True
--   </pre>
pointsPlot' :: (v ~ BaseSpace c, v ~ V2, PointLike v n (Polar n), MonadState (Axis b c n) m, Plotable (GPointsPlot n) b, RealFloat n) => [(n, Angle n)] -> m ()
instance Diagrams.Core.Envelope.OrderedField n => Diagrams.Core.Envelope.Enveloped (Plots.Types.Points.GPointsPlot n)
instance (v ~ Linear.V2.V2, Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path v n) b) => Plots.Types.Plotable (Plots.Types.Points.GPointsPlot n) b
instance Plots.Types.Points.HasPoints (Plots.Types.Points.GPointsPlot n) n
instance Plots.Types.Points.HasPoints (Plots.Types.Plot (Plots.Types.Points.GPointsPlot n) b) n

module Plots.Types.Others
createlinerangev :: (Double, Double) -> Double -> [(Double, Double)]
linerangevPlot :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> m ()
linerangevPlot' :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> m ()
linerangevPlotwithPoint :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> m ()
createlinerangeh :: (Double, Double) -> Double -> [(Double, Double)]
linerangehPlot :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> m ()
linerangehPlot' :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> m ()
linerangehPlotwithPoint :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> m ()
errorbarvPlot :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> Double -> m ()
errorbarvPlotwithPoint :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> Double -> m ()
errorbarhPlot :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> Double -> m ()
errorbarhPlotwithPoint :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> Double -> m ()
crossbarvPlot :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> Double -> m ()
crossbarvPlotwithPoint :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> Double -> m ()
crossbarhPlot :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> Double -> m ()
crossbarhPlotwithPoint :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> Double -> m ()
boxplotvPlot :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> Double -> Double -> m ()
boxplothPlot :: (Typeable b, Renderable (Path V2 Double) b, MonadState (Axis b c Double) m, BaseSpace c ~ V2) => (Double, Double) -> Double -> Double -> Double -> m ()


-- | Low level module containing functions for rendering different types of
--   axis.
module Plots.Axis.Render
class RenderAxis b v n
renderAxis :: RenderAxis b v n => Axis b v n -> QDiagram b (BaseSpace v) n Any
renderR2Axis :: (Typeable b, TypeableFloat n, Renderable (Path V2 n) b, Renderable (Text n) b) => Axis b V2 n -> QDiagram b V2 n Any

-- | The position of axis labels for a
data LabelPosition
NoLabels :: LabelPosition
LowerLabels :: LabelPosition
LeftLabels :: LabelPosition
RightLabels :: LabelPosition
UpperLabels :: LabelPosition
axisOnBasis :: (v ~ V2, TypeableFloat n, HasLinearMap v, Metric v, Renderable (Path V2 n) b, n ~ N (v n), v ~ V (v n), OrderedField n) => Point v n -> v (n, n) -> SingleAxis b v n -> v LogScale -> T2 n -> E v -> E v -> LabelPosition -> QDiagram b V2 n Any

-- | Stroke without any envelope, trace, query etc.
primStroke :: (Ord n, Typeable n, Typeable v, Renderable (Path v n) b) => Path v n -> QDiagram b v n Any
translationE :: (Num n, HasLinearMap v) => E v -> n -> Transformation v n
scaleE :: (Additive v, Fractional n) => E v -> n -> Transformation v n
getAxisLinePos :: (Num n, Ord n) => (n, n) -> AxisLineType -> [(AxisPos, n)]
data AxisPos
LowerAxis :: AxisPos
MiddleAxis :: AxisPos
UpperAxis :: AxisPos
ep :: E v -> Lens' (Point v x) x
renderPolarAxis :: (Typeable b, Enum n, TypeableFloat n, Renderable (Path V2 n) b, Renderable (Text n) b) => Axis b Polar n -> QDiagram b V2 n Any
instance GHC.Classes.Eq Plots.Axis.Render.LabelPosition
instance GHC.Show.Show Plots.Axis.Render.LabelPosition
instance (Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b, Diagrams.Core.Types.Renderable (Diagrams.TwoD.Text.Text n) b) => Plots.Axis.Render.RenderAxis b Linear.V2.V2 n
instance (Data.Typeable.Internal.Typeable b, GHC.Enum.Enum n, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b, Diagrams.Core.Types.Renderable (Diagrams.TwoD.Text.Text n) b) => Plots.Axis.Render.RenderAxis b Diagrams.Coordinates.Polar.Polar n

module Plots.CmdLine

-- | <a>mainWith</a> specialised to a 2D Axis.
r2AxisMain :: (Parseable (MainOpts (QDiagram b V2 Double Any)), Mainable (Axis b V2 Double)) => Axis b V2 Double -> IO ()
instance (Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.TwoD.Text.Text n) b, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b, Diagrams.Core.Types.Backend b Linear.V2.V2 n, Diagrams.Backend.CmdLine.Mainable (Diagrams.Core.Types.QDiagram b Linear.V2.V2 n Data.Monoid.Any)) => Diagrams.Backend.CmdLine.Mainable (Plots.Axis.Axis b Linear.V2.V2 n)
instance Diagrams.Backend.CmdLine.ToResult (Plots.Axis.Axis b v n)


-- | A bar plot is a plot that presents data with rectangular bars with
--   lengths proportional to the values that they represent. The bars can
--   be plotted vertically or horizontally.
module Plots.Types.Bar

-- | A bar plot for a single set of bars. Multi-bar plots are achieved by
--   having multiple <a>BarPlot</a>s. Each bar plot corresponds to a single
--   legend entry. To get multiple bar entries/colours, use multiple
--   <tt>BarPlots</tt>
data BarPlot n

-- | A add <a>BarPlot</a> to an <a>Axis</a>.
barPlot :: (MonadState (Axis b V2 n) m, Plotable (BarPlot n) b, Foldable f) => f n -> State (Plot (BarPlot n) b) () -> m ()

-- | Simple version of <a>barPlot</a> without any modification to the
--   <a>Plot</a>.
barPlot' :: (MonadState (Axis b V2 n) m, Plotable (BarPlot n) b, Foldable f) => f n -> m ()

-- | A add <a>BarPlot</a> to an <a>Axis</a> while naming the bars.
namedBarPlot :: (MonadState (Axis b V2 n) m, Plotable (BarPlot n) b, Foldable f) => f (String, n) -> State (Plot (BarPlot n) b) () -> m ()

-- | Simple version of <a>namedBarPlot</a> without any modification to the
--   <a>Plot</a>.
namedBarPlot' :: (MonadState (Axis b V2 n) m, Plotable (BarPlot n) b, Foldable f) => f (String, n) -> m ()

-- | Same as <a>barPlot</a> but with lower and upper bounds for the bars.
floatingBarPlot :: (MonadState (Axis b V2 n) m, Plotable (BarPlot n) b, Foldable f) => f (n, n) -> State (Plot (BarPlot n) b) () -> m ()

-- | The way an individual bar plot or a group of bars plots are laid out
--   on the axis.
data BarLayout n

-- | Class of things that have a modifiable <a>BarLayout</a>.
class HasOrientation a => HasBarLayout a where barWidth = barLayout . lens bWidth (\ bl w -> bl {bWidth = w}) barSpacing = barLayout . lens bSpacing (\ bl s -> bl {bSpacing = s}) barStart = barLayout . lens bStart (\ bl x -> bl {bStart = x})

-- | Lens onto the <a>BarLayout</a>
barLayout :: HasBarLayout a => Lens' a (BarLayout (N a))

-- | The width bar for single / stacked bars or the width of a group for
--   grouped bar plot.
--   
--   Default is <tt>0.8</tt>
barWidth :: HasBarLayout a => Lens' a (N a)

-- | The spacing between each bar or group of bars.
--   
--   Default is <tt>1</tt>
barSpacing :: HasBarLayout a => Lens' a (N a)

-- | The distance from the axis to centre of the first bar.
--   
--   Default is <tt>1</tt>
barStart :: HasBarLayout a => Lens' a (N a)

-- | Construct multiple bars, grouped together. See <a>MultiBarState</a>
--   for details on how to customise how the bars are drawn.
multiBars :: (MonadState (Axis b V2 n) m, Plotable (BarPlot n) b, Foldable f, Foldable g) => f a -> (a -> g n) -> State (MultiBarState b n a) () -> m ()

-- | The <a>MultiBarState</a> is used to set the various options available
--   when building multiple bar plots together. The main functions used to
--   modify this state:
--   
--   <ul>
--   <li>To choose the way the bars are grouped together choose one
--   of<ul><li><a>groupedBars</a> - Together in grouped (the
--   default)</li><li><a>stackedBars</a> - On on top of
--   another</li><li><a>stackedEqualBars</a> - <a>stackedBars</a> with the
--   same height</li><li><a>runningBars</a> - each group of bars follows
--   the last</li></ul></li>
--   <li>Modify the <a>PlotOptions</a> and <a>PlotStyle</a> of groups of
--   bars with <a>onBars</a>.</li>
--   <li>Modify the layout of the (groups of) bars
--   with<ul><li><a>orientation</a> - Horizontal or vertical
--   bars</li><li><a>barWidth</a> - Width of each (group of)
--   bar(s)</li><li><a>barSpacing</a> - Space between each (group of)
--   bar(s)</li><li><a>barStart</a> - Start of centre of first
--   bar</li></ul></li>
--   <li>Add labels to each (group of) bars with <a>labelBars</a>.</li>
--   </ul>
data MultiBarState b n a

-- | Bars that are grouped together such that each group is a single
--   <a>barWidth</a>. The bars in a group are touching, see groupedBars' to
--   reduce the width of individual bars.
groupedBars :: Fractional n => State (MultiBarState b n a) ()

-- | Bars that are grouped together such that each group is a single
--   <a>barWidth</a>. The parameter is the multiplier for the width of
--   individual bars, where <tt><a>groupedBars</a> 1 = groupedBars</tt>
--   corresponds to bars in a group touching. reduce the width of
--   individual bars.
groupedBars' :: Fractional n => n -> State (MultiBarState b n a) ()

-- | Bars stacked on top of each other.
stackedBars :: Num n => State (MultiBarState b n a) ()

-- | Bars stacked on top of each other where every bar is the given height.
stackedEqualBars :: Fractional n => n -> State (MultiBarState b n a) ()

-- | Normal <tt>bars</tt> where each data set follows the last.
runningBars :: Num n => State (MultiBarState b n a) ()

-- | Given the data for the bar, modify the properties for the bar that
--   uses that data.
--   
--   Some common functions to use on the <a>PlotMods</a>:
--   
--   <ul>
--   <li><a>plotColour</a> - change the colour of the bars</li>
--   <li><a>areaStyle</a> - modify the style of the bars</li>
--   <li><a>key</a> - add a legend entry for that group of bars</li>
--   </ul>
onBars :: (a -> State (PlotMods b V2 n) ()) -> State (MultiBarState b n a) ()

-- | Labels to use for each bar (or group of bars) along the axis.
labelBars :: HasLabels a => [String] -> State a ()

-- | Create equidistant bars using the values.
mkBars :: (Foldable f, Num n) => BarLayout n -> f n -> BarPlot n

-- | Create equidistant bars with lower and upper bounds for each bar.
mkFloatingBars :: (Foldable f, Num n) => BarLayout n -> f (n, n) -> BarPlot n

-- | Create uniform bars from groups of data, placing one group after the
--   other.
mkRunningBars :: Num n => BarLayout n -> [[(n, n)]] -> [BarPlot n]

-- | Create uniform bars from groups of data, placing one on top of the
--   other. The first list will be the same as <tt>mkUniformBars opts (map
--   (0,) ys)</tt>, subsequent lists will be placed on top.
mkStackedBars :: Num n => BarLayout n -> [[n]] -> [BarPlot n]

-- | Similar to <tt>mkMultiStacked</tt> but stack has the same height.
mkStackedEqualBars :: Fractional n => n -> BarLayout n -> [[n]] -> [BarPlot n]

-- | Make bars that are grouped together. Each group of bars is treated as
--   a single bar when using the <tt>BarPlotsOpts</tt>. There is an
--   addition parameter to adjust the width of each individual bar.
mkGroupedBars :: Fractional n => n -> BarLayout n -> [[n]] -> [BarPlot n]
instance GHC.Real.Fractional n => Data.Default.Class.Default (Plots.Types.Bar.BarLayout n)
instance Plots.Types.HasOrientation (Plots.Types.Bar.BarLayout n)
instance Plots.Types.Bar.HasBarLayout (Plots.Types.Bar.BarLayout n)
instance Plots.Types.Bar.HasBarLayout a => Plots.Types.Bar.HasBarLayout (Plots.Types.Plot a b)
instance Plots.Types.HasOrientation (Plots.Types.Bar.BarPlot n)
instance Diagrams.Core.Envelope.OrderedField n => Diagrams.Core.Envelope.Enveloped (Plots.Types.Bar.BarPlot n)
instance (Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.Bar.BarPlot n) b
instance Plots.Types.Bar.HasBarLayout (Plots.Types.Bar.BarPlot n)
instance Plots.Types.HasOrientation (Plots.Types.Bar.MultiBarState b n a)
instance Plots.Types.Bar.HasBarLayout (Plots.Types.Bar.MultiBarState b n a)
instance Plots.Types.Bar.HasLabels (Plots.Types.Bar.MultiBarState b n a)

module Plots.Types.HeatMap

-- | 2D Array of <a>Double</a>s.
data HeatMatrix
HeatMatrix :: !(V2 Int) -> (V2 Int -> Double) -> HeatMatrix
[hmSize] :: HeatMatrix -> !(V2 Int)
[hmFun] :: HeatMatrix -> V2 Int -> Double

-- | Create a heat matrix from an extent and a function to extract the
--   values.
mkHeatMatrix :: V2 Int -> (V2 Int -> Double) -> HeatMatrix

-- | Create a heat matrix from a list of lists of values. All sublists
--   should have the same length
mkHeatMatrix' :: Foldable f => f (f Double) -> HeatMatrix

-- | Normalise a heat matrix so all values lie in the (0,1) range. Also
--   returns the lower and upper limit of the original heat matrix.
normaliseHeatMatrix :: HeatMatrix -> ((Double, Double), HeatMatrix)

-- | Indexed traversal over the values of a <a>HeatMatrix</a>.
hmPoints :: IndexedTraversal' (V2 Int) HeatMatrix Double

-- | Render an heatmap as an image.
pixelHeatRender :: (Renderable (DImage n Embedded) b, TypeableFloat n) => HeatMatrix -> ColourMap -> QDiagram b V2 n Any
heatImage :: HeatMatrix -> ColourMap -> Image PixelRGB8
colourToPixel :: Colour Double -> PixelRGB8

-- | Render the heat map as squares.
pathHeatRender :: (Renderable (Path V2 n) b, TypeableFloat n) => HeatMatrix -> ColourMap -> QDiagram b V2 n Any
data HeatMap b n
HeatMap :: HeatMatrix -> P2 n -> V2 n -> Style V2 n -> Bool -> Maybe (Double, Double) -> (HeatMatrix -> ColourMap -> QDiagram b V2 n Any) -> HeatMap b n
[hMatrix] :: HeatMap b n -> HeatMatrix
[hStart] :: HeatMap b n -> P2 n
[hSize] :: HeatMap b n -> V2 n
[hGridSty] :: HeatMap b n -> Style V2 n
[hGridVisible] :: HeatMap b n -> Bool
[hLimits] :: HeatMap b n -> Maybe (Double, Double)
[hDraw] :: HeatMap b n -> HeatMatrix -> ColourMap -> QDiagram b V2 n Any

-- | Class of things that let you change the heatmap options.
class HasHeatMap f a b | a -> b where heatMapGridVisible = heatMapOptions . lens hGridVisible (\ s b -> (s {hGridVisible = b})) heatMapGridStyle = heatMapOptions . lens hGridSty (\ s b -> (s {hGridSty = b})) heatMapSize = heatMapOptions . lens hSize (\ s b -> (s {hSize = b})) heatMapStart = heatMapOptions . lens hStart (\ s b -> (s {hStart = b})) heatMapLimits = heatMapOptions . lens hLimits (\ s b -> (s {hLimits = b})) heatMapRender = heatMapOptions . lens hDraw (\ s b -> (s {hDraw = b}))

-- | Lens onto the heatmap options.
heatMapOptions :: HasHeatMap f a b => LensLike' f a (HeatMap b (N a))

-- | Whether there should be grid lines draw for the heat map. Default is
--   <a>False</a>.
heatMapGridVisible :: (HasHeatMap f a b, Functor f) => LensLike' f a Bool

-- | The style applied to the grid lines for the heat map, if they're
--   visible.
heatMapGridStyle :: (HasHeatMap f a b, Functor f) => LensLike' f a (Style V2 (N a))

-- | The size of each individual square in the heat map.
heatMapSize :: (HasHeatMap f a b, Functor f) => LensLike' f a (V2 (N a))

-- | The starting point for the heat map.
heatMapStart :: (HasHeatMap f a b, Functor f) => LensLike' f a (P2 (N a))

-- | Limits <tt>(a,b)</tt> used on the data such that <tt>a</tt> is the
--   start of the <a>ColourMap</a> and <tt>b</tt> is the end of the
--   <a>ColourMap</a>. Default is <tt>(0,1)</tt>.
heatMapLimits :: (HasHeatMap f a b, Functor f) => LensLike' f a (Maybe (Double, Double))

-- | Funtion used to render the heat map.
heatMapRender :: (HasHeatMap f a b, Functor f) => LensLike' f a (HeatMatrix -> ColourMap -> QDiagram b V2 (N a) Any)

-- | Construct a <tt>Heatmap</tt> using the given <a>HeatMatrix</a>.
mkHeatMap :: (Renderable (Path V2 n) b, TypeableFloat n) => HeatMatrix -> HeatMap b n

-- | Add a <a>HeatMap</a> plot using the extent of the heatmap and a
--   generating function.
--   
--   <pre>
--   <a>heatMap</a> :: <a>V2</a> <a>Int</a>     -&gt; (<a>V2</a> <a>Int</a> -&gt; <a>Double</a>)     -&gt; <a>State</a> (<a>Plot</a> (<a>HeatMap</a> b n)) () -&gt; <a>State</a> (<a>Axis</a> b <a>V2</a> n) ()
--   <a>heatMap</a> :: (<a>Int</a>, <a>Int</a>) -&gt; ((<a>Int</a>, <a>Int</a>) -&gt; <a>Double</a>) -&gt; <a>State</a> (<a>Plot</a> (<a>HeatMap</a> b n)) () -&gt; <a>State</a> (<a>Axis</a> b <a>V2</a> n) ()
--   </pre>
heatMap :: (VectorLike V2 Int i, TypeableFloat n, Typeable b, MonadState (Axis b V2 n) m, Renderable (Path V2 n) b) => i -> (i -> Double) -> State (Plot (HeatMap b n) b) () -> m ()
instance Plots.Types.HeatMap.HasHeatMap f (Plots.Types.HeatMap.HeatMap b n) b
instance (GHC.Base.Functor f, Plots.Types.HeatMap.HasHeatMap f a b) => Plots.Types.HeatMap.HasHeatMap f (Plots.Types.Plot a b) b
instance Diagrams.Core.Envelope.OrderedField n => Diagrams.Core.Envelope.Enveloped (Plots.Types.HeatMap.HeatMap b n)
instance (Data.Typeable.Internal.Typeable b, Diagrams.Core.Types.TypeableFloat n, Diagrams.Core.Types.Renderable (Diagrams.Path.Path Linear.V2.V2 n) b) => Plots.Types.Plotable (Plots.Types.HeatMap.HeatMap b n) b


-- | This module defines types for axis labels and tick labels.
module Plots

-- | Add a <a>ScatterPlot</a> to the <tt>AxisState</tt> from a data set.
--   
--   <pre>
--   myaxis = r2Axis ~&amp;
--     scatterPlot data1
--   </pre>
--   
--   <h3><b>Example</b></h3>
--   
--   
--   <pre>
--   mydata1 = [(1,3), (2,5.5), (3.2, 6), (3.5, 6.1)]
--   mydata2 = mydata1 &amp; each . _1 *~ 0.5
--   mydata3 = [V2 1.2 2.7, V2 2 5.1, V2 3.2 2.6, V2 3.5 5]
--   
--   myaxis :: Axis B V2 Double
--   myaxis = r2Axis &amp;~ do
--     scatterPlot mydata1 $ key "data 1"
--     scatterPlot mydata2 $ key "data 2"
--     scatterPlot mydata3 $ key "data 3"
--   </pre>
scatterPlot :: (BaseSpace c ~ v, PointLike v n p, Typeable n, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b, Foldable f) => f p -> State (Plot (ScatterOptions v n (Point v n)) b) () -> m ()

-- | Scatter plots with extra numeric parameter. By default the extra
--   parameter is the scale of the marker but this can be changed.
bubblePlot :: (BaseSpace c ~ v, PointLike v n p, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b, Typeable n, Foldable f) => f (n, p) -> State (Plot (BubbleOptions v n) b) () -> m ()

-- | A general scatter plot allow using any data type <tt>d</tt> to
--   determine the <a>scatterTransform</a> and <a>scatterStyle</a>.
gscatterPlot :: (BaseSpace c ~ v, PointLike v n p, MonadState (Axis b c n) m, Plotable (ScatterPlot v n) b, Typeable d, Foldable f) => f d -> (d -> p) -> State (Plot (ScatterOptions v n d) b) () -> m ()
linePlot :: (v ~ BaseSpace c, PointLike v n p, MonadState (Axis b c n) m, Plotable (LinePlot v n) b, Foldable f) => f p -> State (Plot (LinePlot v n) b) () -> m ()

-- | Similar to '(%=)' but takes a state modification instead of a
--   function.
(&=) :: MonadState s m => ASetter' s b -> State b a -> m ()

-- | Similar to '(&amp;~)' but works with <a>StateT</a> and returns it in
--   <tt>m</tt>.
(&~~) :: Monad m => s -> StateT s m a -> m s
